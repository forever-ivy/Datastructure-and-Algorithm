# 树

我们可以把“树”想象成一个倒过来的家族族谱或者一个公司的组织架构图。它是一种用来表示层级关系的非线性数据结构。

下面是构成一棵树最核心的基本概念：

---

### 1. 节点 (Node)
*   **定义**：树的最基本组成部分。
*   **类比**：可以想象成族谱里的“每一个人”，或者组织架构图里的“每一个职位”。
*   **包含**：一个节点通常包含两个部分：
    1.  **数据 (Data)**：节点存储的信息，比如人的名字，或者一个数字。
    2.  **指针 (Pointers)**：指向其他相关节点的连接，主要是指向它的子节点。

### 2. 根节点 (Root)
*   **定义**：一棵树最顶端的节点，它是所有其他节点的“祖先”。
*   **特点**：一棵非空的树有且仅有一个根节点。它没有父节点。
*   **类比**：族谱里的“老祖宗”，或者公司的“CEO”。

### 3. 边 (Edge)
*   **定义**：连接两个节点的线。
*   **作用**：表示节点之间的直接关系（父子关系）。
*   **类比**：族谱中连接父母与子女的线。

### 4. 父节点 (Parent) & 子节点 (Child)
*   **定义**：这是一个相对的概念。如果一个节点A通过一条边连接到另一个节点B，并且A在B的上一层，那么A就是B的**父节点**，B就是A的**子节点**。
*   **类比**：就是家族中的父母与子女的关系。

### 5. 兄弟节点 (Sibling)
*   **定义**：拥有同一个父节点的多个节点互为兄弟节点。
*   **类比**：同一个父母生下的几个孩子。

### 6. 叶子节点 (Leaf Node)
*   **定义**：没有任何子节点的节点，也就是“度”为0的节点。
*   **特点**：它们位于树的最末梢。
*   **类比**：族谱中还没有子女的成员。

### 7. 内部节点 (Internal Node)
*   **定义**：除了根节点和叶子节点之外的所有节点。
*   **特点**：它至少有一个子节点。

### 8. 子树 (Subtree)
*   **定义**：树中任意一个节点和它下面的所有后代节点（包括后代的后代）共同构成一个子树。
*   **特点**：子树本身也是一棵完整的树，有自己的根节点（就是那个被选中的节点）。
*   **类比**：在族谱中，任何一个人和他的所有后代（儿子、孙子、曾孙...）可以看成一个“分支家族”或“子树”。

---

### 描述树的“度量”概念

这些概念用来描述树的形态和规模。

### 9. 节点的度 (Degree of a Node)
*   **定义**：一个节点拥有的**子树的个数**，或者说直接相连的**子节点的个数**。
*   **举例**：一个节点有两个孩子，它的度就是2。叶子节点的度是0。

### 10. 树的度 (Degree of a Tree)
*   **定义**：一棵树中，**所有节点度数的最大值**。
*   **举例**：如果一棵树里，某个节点的子节点最多（比如有3个），那么这棵树的度就是3。我们之前讨论的**二叉树**，它的度就是2，因为任何节点最多只能有两个孩子。

### 11. 层 (Level)
*   **定义**：节点的层级。通常规定根节点在第1层，它的孩子在第2层，以此类推。

### 12. 深度 (Depth)
*   **定义**：**从根节点开始自顶向下**到某一节点所经过的边的数量。
*   **规定**：根节点的深度为0。它的孩子的深度为1，以此类推。
*   **注意**：一个节点的深度和它所在的层数通常相差1（当层数从1开始算时）。

### 13. 高度 (Height)
*   **定义**：**从某一节点开始自底向上**到其最远的叶子节点所经过的边的数量。
*   **规定**：叶子节点的高度为0。
*   **树的高度**：特指**根节点的高度**，也就是整棵树的最大层数。

**高度和深度的关系**：对于整棵树来说，**树的高度 = 最深叶子节点的深度**。

### 总结与回顾

| 概念 | 通俗解释 (以家族族谱为例) |
| :--- | :--- |
| **节点 (Node)** | 家族里的每一个人 |
| **根节点 (Root)** | 家族的老祖宗 |
| **父节点 (Parent)** | 某个人的父亲或母亲 |
| **子节点 (Child)** | 某个人的儿子或女儿 |
| **兄弟节点 (Sibling)** | 亲兄弟姐妹 |
| **叶子节点 (Leaf)** | 没有孩子的成员 |
| **节点的度 (Degree)** | 一个人有几个孩子 |
| **深度 (Depth)** | 从老祖宗到某个人，中间隔了多少代 |
| **高度 (Height)** | 从某个人到他最远的后代，中间隔了多少代 |
| **树的高度 (Height of Tree)** | 整个家族繁衍了多少代 |

希望这份从零开始的梳理能帮助您重新建立起对树的基本认识。理解了这些基础词汇，再去看“二叉树”、“满二叉树”、“完全二叉树”等具体概念就会清晰很多。
## 二叉树的种类

在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。

### [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91)满二叉树

满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

如图所示：

![](https://file1.kamacoder.com/i/algo/20200806185805576.png)

这棵二叉树为满二叉树，也可以说深度为k，有2^k-1个节点的二叉树。

### [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)完全二叉树

什么是完全二叉树？

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。

**大家要自己看完全二叉树的定义，很多同学对完全二叉树其实不是真正的懂了。**

我来举一个典型的例子如题：

![](https://file1.kamacoder.com/i/algo/20200920221638903.png)

相信不少同学最后一个二叉树是不是完全二叉树都中招了。

**之前我们刚刚讲过优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。**

### [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

下面这两棵树都是搜索树

![](https://file1.kamacoder.com/i/algo/20200806190304693.png)

### [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91)平衡二叉搜索树

平衡二叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如图：

![](https://file1.kamacoder.com/i/algo/20200806190511967.png)

最后一棵 不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中map、set、multimap，multiset的底层实现都是平衡二叉搜索树**，所以map、set的增删操作时间时间复杂度是logn，注意我这里没有说unordered_map、unordered_set，unordered_map、unordered_set底层实现是哈希表。

**所以大家使用自己熟悉的编程语言写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是map、set等等，否则自己写的代码，自己对其性能分析都分析不清楚！**

## [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F)二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

那么链式存储方式就用指针， 顺序存储的方式就是用数组。

顾名思义就是顺序存储的元素在内存是连续分布的，而链式存储则是通过指针把分布在各个地址的节点串联一起。

链式存储如图：

![](https://file1.kamacoder.com/i/algo/2020092019554618.png)

链式存储是大家很熟悉的一种方式，那么我们来看看如何顺序存储呢？

其实就是用数组来存储二叉树，顺序存储的方式如图：

![](https://file1.kamacoder.com/i/algo/20200920200429452.png)

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

**所以大家要了解，用数组依然可以表示二叉树。**

## [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F)二叉树的遍历方式

关于二叉树的遍历方式，要知道二叉树遍历的基本方式都有哪些。

一些同学用做了很多二叉树的题目了，可能知道前中后序遍历，可能知道层序遍历，但是却没有框架。

我这里把二叉树的几种遍历方式列出来，大家就可以一一串起来了。

二叉树主要有两种遍历方式：

1. 深度优先遍历：先往深走，遇到叶子节点再往回走。
2. 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式**，后面在介绍图论的时候 还会介绍到。

那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：

- 深度优先遍历
    - 前序遍历（递归法，迭代法）
    - 中序遍历（递归法，迭代法）
    - 后序遍历（递归法，迭代法）
- 广度优先遍历
    - 层次遍历（迭代法）

在深度优先遍历中：有三个顺序，前中后序遍历， 有同学总分不清这三个顺序，经常搞混，我这里教大家一个技巧。

**这里前中后，其实指的就是中间节点的遍历顺序**，只要大家记住 前中后序指的就是中间节点的位置就可以了。

看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历方式

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

大家可以对着如下图，看看自己理解的前后中序有没有问题。

![](https://file1.kamacoder.com/i/algo/20200806191109896.png)

最后再说一说二叉树中深度优先和广度优先遍历实现方式，我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。

**之前我们讲栈与队列的时候，就说过栈其实就是递归的一种实现结构**，也就说前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的。

而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

**这里其实我们又了解了栈与队列的一个应用场景了。**

具体的实现我们后面都会讲的，这里大家先要清楚这些理论基础。

## [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89)二叉树的定义

刚刚我们说过了二叉树有两种存储方式顺序存储，和链式存储，顺序存储就是用数组来存，这个定义没啥可说的，我们来看看链式存储的二叉树节点的定义方式。

C++代码如下：

```
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

大家会发现二叉树的定义 和链表是差不多的，相对于链表 ，二叉树的节点里多了一个指针， 有两个指针，指向左右孩子。

这里要提醒大家要注意二叉树节点定义的书写方式。

**在现场面试的时候 面试官可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要锻炼白纸写出来。**

因为我们在刷leetcode的时候，节点的定义默认都定义好了，真到面试的时候，需要自己写节点定义的时候，有时候会一脸懵逼！

## [#](https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html#%E6%80%BB%E7%BB%93)总结

二叉树是一种基础数据结构，在算法面试中都是常客，也是众多数据结构的基石。

本篇我们介绍了二叉树的种类、存储方式、遍历方式以及定义，比较全面的介绍了二叉树各个方面的重点，帮助大家扫一遍基础。

**说到二叉树，就不得不说递归，很多同学对递归都是又熟悉又陌生，递归的代码一般很简短，但每次都是一看就会，一写就废。**