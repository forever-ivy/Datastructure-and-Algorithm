
## **🌳 一、Map 系列（键值对容器）**

|**容器**|**有序性**|**底层**|**查找复杂度**|**典型用途**|**适用场景**|
|---|---|---|---|---|---|
|**std::map**|✅ 按 key 排序|红黑树|O(log n)|键值对存储、自动按 key 排序|需要按 key 有序遍历，如：排行榜、区间查询|
|**std::multimap**|✅ 按 key 排序|红黑树|O(log n)|允许重复 key|一个 key 对应多个值，例如同一日期多条记录|
|**std::unordered_map**|❌ 无序|哈希表|平均 O(1)|快速查找|频繁查找/插入，如计数统计、哈希缓存|
|**std::unordered_multimap**|❌ 无序|哈希表|平均 O(1)|允许重复 key|快速分组存储且允许重复，例如日志分组|

**补充**：

- 需要**范围查询**或**顺序遍历** → map/multimap
    
- 需要**最快的单点查找** → unordered_map
    

---

## **🌿 二、Set 系列（集合容器，只有键）**

|**容器**|**有序性**|**底层**|**查找复杂度**|**典型用途**|**适用场景**|
|---|---|---|---|---|---|
|**std::set**|✅ 自动排序|红黑树|O(log n)|唯一且有序|排序+去重，如有序排行榜、字典|
|**std::multiset**|✅ 自动排序|红黑树|O(log n)|允许重复|需要排序且可重复，例如多重计数|
|**std::unordered_set**|❌ 无序|哈希表|平均 O(1)|唯一但无序|去重、快速存在性判断，如单词去重|
|**std::unordered_multiset**|❌ 无序|哈希表|平均 O(1)|允许重复|频繁统计重复元素但不关心顺序|

**补充**：

- 需要**自动排序** → set/multiset
    
- 只需**快速判断是否存在** → unordered_set
    

---

## **📦 三、数组 & Vector**

|**容器**|**是否动态**|**有序性**|**访问复杂度**|**典型用途**|**适用场景**|
|---|---|---|---|---|---|
|**原生数组 int arr[N]**|❌ 固定大小|顺序|随机访问 O(1)|小规模、固定长度数据|性能敏感、大小固定（如图像像素、内存池）|
|**std::vector**|✅ 自动扩容|顺序|随机访问 O(1)|通用动态数组|存放任意数量顺序数据、频繁 push_back|

---

## **🗂️ 场景对照速查**

|**需求**|**推荐容器**|**说明**|
|---|---|---|
|**频繁随机访问/按索引**|array / vector|下标访问最快|
|**自动去重 + 排序**|set|插入后始终有序|
|**需要多份相同数据且排序**|multiset|允许重复|
|**快速判断是否存在**|unordered_set|哈希平均 O(1)|
|**键值映射 + 有序遍历**|map|排序键|
|**键值映射 + 允许重复键**|multimap|一键多值|
|**键值映射 + 高速查找**|unordered_map|平均 O(1)|
|**键值映射 + 高速查找 + 重复键**|unordered_multimap|一键多值、无序|
|**顺序插入删除较多**|list / deque|双端或链表，非题主重点|

---

### **🏁 总结口诀**

- **索引访问首选**：数组/vector
    
- **有序且唯一**：set / map
    
- **允许重复**：multiset / multimap
    
- **无序但极速**：unordered_* 系列
    

  

这样一看，只要想清楚：

  

> _是否需要键值对_ ➜ _是否需要排序_ ➜ _是否允许重复_

> 就能快速锁定合适的 STL 容器。