
### C++ 代码实现


迭代版本的效率通常略高，因为它避免了函数调用的开销。在性能要求高的场景下更常用。

```
#include <iostream>

// 递归实现的辗转相除法
int gcd_recursive(int a, int b) {
    // 基线条件：如果 b 为 0，那么 a 就是最大公约数
    if (b == 0) {
        return a;
    }
    // 递归步骤：用 b 和 a % b 继续求解
    return gcd_recursive(b, a % b);
}

int main() {
    int num1 = 48, num2 = 18;
    int result = gcd_recursive(num1, num2);
    std::cout << "The GCD of " << num1 << " and " << num2 << " is: " << result << std::endl; // 输出: 6

    num1 = 101, num2 = 10;
    result = gcd_recursive(num1, num2);
    std::cout << "The GCD of " << num1 << " and " << num2 << " is: " << result << std::endl; // 输出: 1
    return 0;
}

```

---

### 代码解析

#### 核心数学原理：欧几里得算法

辗转相除法的数学基础是一个非常古老且优美的定理：  
**两个整数 a 和 b 的最大公约数，等于 b 和 a 除以 b 的余数（a % b）的最大公约数。**

用数学公式表达就是： gcd(a, b) = gcd(b, a % b)

这个过程会一直持续下去，直到其中一个数变为 0。当 b 变为 0 时，剩下的 a 就是原始两个数的最大公约数。

#### 示例追踪 (计算 gcd(48, 18))

让我们用这个原理来手动追踪一下算法的执行过程：

1. **初始状态**: a = 48, b = 18
    
    - gcd(48, 18)
        
2. **第 1 步**:
    
    - a % b = 48 % 18 = 12
        
    - 问题转化为求 gcd(18, 12)
        
3. **第 2 步**:
    
    - a % b = 18 % 12 = 6
        
    - 问题转化为求 gcd(12, 6)
        
4. **第 3 步**:
    
    - a % b = 12 % 6 = 0
        
    - 问题转化为求 gcd(6, 0)
        
5. **第 4 步**:
    
    - 此时，第二个参数 b 为 0。根据算法，当 b=0 时，最大公约数就是 a。
        
    - 所以 gcd(6, 0) 的结果是 6。
        

最终，我们得出 gcd(48, 18) = 6。

#### 代码逻辑解析

**1. 递归版本 (gcd_recursive)**

- if (b == 0): 这是递归的**基线条件 (Base Case)**。当 b 经过多次取余运算后最终变为 0，递归就停止了，此时的 a 就是最终答案，函数将其返回。
    
- return gcd_recursive(b, a % b);: 这是**递归步骤 (Recursive Step)**。函数调用自身，但是参数变小了：原来的 b 变成了新的 a，而 a % b（余数）变成了新的 b。这个过程不断重复，直到触发基线条件。
    

**2. 迭代版本 (gcd_iterative)**

- while (b != 0): 循环的条件和递归的基线条件是对应的。只要 b 不为 0，计算就继续。
    
- int temp = b;: 因为在下一步中 b 的值将被 a % b 覆盖，所以我们需要一个临时变量 temp 来保存 b 的原始值。
    
- b = a % b;: 更新 b 为余数。
    
- a = temp;: 更新 a 为原来 b 的值。
    
- return a;: 当 while 循环因为 b 变为 0 而结束时，a 中存储的就是最后一次非零的余数，也就是最大公约数。
    

总的来说，两种方法都完美地实现了辗转相除法的思想，只是在编程范式上有所不同。迭代法在性能上略有优势，而递归法在代码表达上更为简洁直观。