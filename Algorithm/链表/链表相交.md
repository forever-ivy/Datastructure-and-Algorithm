
```
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        ListNode* curA = headA;
        ListNode* curB = headB;
        int lenA = 0, lenB = 0;
        while (curA != NULL) { // 求链表A的长度
            lenA++;
            curA = curA->next;
        }
        while (curB != NULL) { // 求链表B的长度
            lenB++;
            curB = curB->next;
        }
        curA = headA;
        curB = headB;
        // 让curA为最长链表的头，lenA为其长度
        if (lenB > lenA) {
            swap (lenA, lenB);
            swap (curA, curB);
        }
        // 求长度差
        int gap = lenA - lenB;
        // 让curA和curB在同一起点上（末尾位置对齐）
        while (gap--) {
            curA = curA->next;
        }
        // 遍历curA 和 curB，遇到相同则直接返回
        while (curA != NULL) {
            if (curA == curB) {
                return curA;
            }
            curA = curA->next;
            curB = curB->next;
        }
        return NULL;
    }
};
```



### 核心思想

如果两个链表相交，那么从相交节点开始，一直到链表末尾，这两个链表的所有节点都是**完全重合**的（因为它们是同一个节点的引用）。

这就带来一个重要的推论：
> 如果两个链表相交，那么它们各自从头节点到末尾节点的路径长度可能会不同，但它们从**相交节点到末尾节点的路径长度一定是相同的**。

因此，两个链表长度的差异，完全是由**相交点之前**的部分造成的。

算法的策略就是：
1.  找出哪个链表更长。
2.  让长链表的指针先走几步，这几步的步数正好是两个链表的长度差。
3.  这样一来，两个链表的指针就“末尾对齐”了，它们距离各自链表末尾的距离变得相等。
4.  然后，让两个指针同步前进，它们第一次相遇的节点，就是第一个相交节点。

---

### 代码逐行解析与图解

我们用一个例子来可视化整个过程：

*   **链表A**: `[a1] -> [a2] -> [c1] -> [c2] -> [c3] -> null` (长度 lenA = 5)
*   **链表B**: `[b1] -> [c1] -> [c2] -> [c3] -> null` (长度 lenB = 4)
*   它们在节点 `[c1]` 处相交。

**1. 计算两个链表的长度**

```cpp
ListNode* curA = headA;
ListNode* curB = headB;
int lenA = 0, lenB = 0;
while (curA != NULL) { // 求链表A的长度
    lenA++;
    curA = curA->next;
}
while (curB != NULL) { // 求链表B的长度
    lenB++;
    curB = curB->next;
}
```

*   第一个 `while` 循环遍历链表A，得到 `lenA = 5`。
*   第二个 `while` 循环遍历链表B，得到 `lenB = 4`。
*   执行完毕后，`curA` 和 `curB` 都指向 `null`。

**2. 重置指针，并确定长短链表**

```cpp
curA = headA;
curB = headB;
// 让curA为最长链表的头，lenA为其长度
if (lenB > lenA) {
    swap (lenA, lenB);
    swap (curA, curB);
}
```
*   `curA` 和 `curB` 被重置回各自的头节点。
*   此时 `lenB (4) > lenA (5)` 不成立，`if` 语句不执行。
*   现在我们能确定：`curA` 指向长链表（链表A）的头，`lenA` 是其长度。

**3. 计算长度差，对齐起点**

```cpp
// 求长度差
int gap = lenA - lenB;
// 让curA和curB在同一起点上（末尾位置对齐）
while (gap--) {
    curA = curA->next;
}
```
*   `gap = 5 - 4 = 1`。
*   `while` 循环执行1次。
*   `curA` 从 `[a1]` 向前移动一步，指向 `[a2]`。

**当前状态图解：**

```
A: [a1] -> [a2] -> [c1] -> [c2] -> [c3] -> null
             ^
             |
            curA (长链表指针已前进gap步)

B: [b1] -> [c1] -> [c2] -> [c3] -> null
     ^
     |
    curB
```
现在，`curA` 和 `curB` 距离它们各自链表的末尾都有4个节点的距离。它们已经“对齐”了。

**4. 同步遍历，寻找交点**

```cpp
// 遍历curA 和 curB，遇到相同则直接返回
while (curA != NULL) {
    if (curA == curB) {
        return curA;
    }
    curA = curA->next;
    curB = curB->next;
}
```
*   现在两个指针一起一步一步地向前走。
*   **第1步**:
    *   `curA` 指向 `[a2]`, `curB` 指向 `[b1]`。它们不相等 (`curA != curB`)。
    *   `curA` 移动到 `[c1]`。
    *   `curB` 移动到 `[c1]`。
*   **第2步**:
    *   `curA` 指向 `[c1]`, `curB` 指向 `[c1]`。它们是同一个节点对象 (`curA == curB`)。
    *   `if` 条件满足，函数返回 `curA` (或 `curB`)，也就是相交节点 `[c1]`。算法结束。

**5. 处理无交点的情况**

如果两个链表不相交，那么在上面的第4步中，`if (curA == curB)` 这个条件永远不会满足。两个指针会一直走到链表的末尾，同时变为 `NULL`。此时 `while` 循环结束，函数最后会执行：

```cpp
return NULL;
```
这正是我们期望的结果。

### 算法总结

*   **时间复杂度: O(lenA + lenB)**。
    *   计算长度 `lenA` 遍历一次A。
    *   计算长度 `lenB` 遍历一次B。
    *   对齐指针遍历 `gap` 步。
    *   同步遍历最多 `lenB` 步。
    *   总的来说是线性时间复杂度。
*   **空间复杂度: O(1)**。
    *   只使用了有限的几个额外指针和变量 (`curA`, `curB`, `lenA`, `lenB`, `gap`)，没有使用与链表长度相关的额外空间。

这是一个非常优雅且高效的解决方案，完美地利用了相交链表的结构特性。