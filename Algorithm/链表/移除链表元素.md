
```
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while (cur->next != NULL) {
            if(cur->next->val == val) {
                ListNode* tmp = cur->next;
                cur->next = cur->next->next;
                delete tmp;
            } else {
                cur = cur->next;
            }
        }
        head = dummyHead->next;
        delete dummyHead;
        return head;
    }
};
```

### 代码解析：使用虚拟头节点移除链表元素

这段 C++ 代码提供了一个非常经典且高效的链表元素删除方案。其核心技巧是使用了**虚拟头节点（Dummy Node）**，这是一种在处理链表问题，尤其是涉及删除操作时，强烈推荐的最佳实践。

#### 核心思想：虚拟头节点

1. **问题的难点**：在常规的链表删除中，最麻烦的情况是**删除头节点**。因为删除头节点需要改变整个链表的 head 指针，而删除中间或尾部节点则只需要改变其**前一个节点**的 next 指针。这就导致需要编写额外的 if 语句来处理头节点，使代码逻辑变得复杂。
    
2. **虚拟节点的解决方案**：虚拟头节点是一个额外的、临时的节点，它被放置在原始链表的真正头节点 head 之前。我们让虚拟节点的 next 指针指向 head。
    
    - **dummyHead -> head -> node1 -> node2 -> ...**
        
3. **带来的好处**：通过引入这个 dummyHead，原始的头节点 head 就变成了一个普通节点，它也有了一个前驱节点（就是 dummyHead）。这样一来，**所有节点的删除操作都得到了统一**：删除任何一个节点，都等同于修改其**前驱节点**的 next 指针。代码不再需要为头节点写特殊逻辑。
    

#### 代码执行流程

1. **初始化**
    
    - ListNode* dummyHead = new ListNode(0);
        
        - 在堆上创建一个新的 ListNode 对象，我们称之为虚拟头节点。它的值是多少并不重要（这里是 0），关键是它提供了一个固定的、永远不会被删除的“锚点”。
            
    - dummyHead->next = head;
        
        - 将虚拟头节点的 next 指针指向原始链表的头节点 head。此时，虚拟节点成功地成为了新链表的“临时”头部。
            
    - ListNode* cur = dummyHead;
        
        - 创建一个工作指针 cur（current 的缩写），并让它从 dummyHead 开始。cur 的作用是作为**待检查节点的前驱节点**。
            
2. **遍历与删除（while 循环）**
    
    - while (cur->next != NULL)
        
        - 循环的条件是 cur 的下一个节点不为空。这意味着 cur 将会遍历到原始链表的最后一个节点，以便检查其后的 NULL。
            
    - if(cur->next->val == val)
        
        - 这是核心判断。我们不判断 cur 当前节点的值，而是判断 cur **下一个节点** (cur->next) 的值是否等于目标值 val。
            
    - **如果需要删除 (if 块内):**
        
        1. ListNode* tmp = cur->next;
            
            - 创建一个临时指针 tmp 指向即将被删除的节点 (cur->next)。这是为了稍后能够安全地释放它的内存。
                
        2. cur->next = cur->next->next;
            
            - **这是删除操作的精髓**。cur 的 next 指针“跳过”了要被删除的节点，直接指向了被删除节点的下一个节点。这样，目标节点就从链中断开了。
                
        3. delete tmp;
            
            - 释放临时指针 tmp 所指向的节点的内存，防止内存泄漏。
                
        4. **关键点**：在这种情况下，cur 指针**不向后移动**。因为 cur->next 已经指向了一个新的节点，这个新节点也可能是需要删除的目标值。cur 必须停在原地，在下一次循环中继续检查这个新的 cur->next。这确保了可以正确处理连续出现的目标值（例如 1 -> 2 -> 2 -> 3 中删除 2）。
            
    - **如果不需要删除 (else 块内):**
        
        - cur = cur->next;
            
        - 如果 cur 的下一个节点的值不是目标值，说明它应该被保留。那么 cur 就可以安全地向后移动一位，为下一次检查做准备。
            
3. **收尾工作**
    
    - head = dummyHead->next;
        
        - 当循环结束后，所有值为 val 的节点都已被移除。dummyHead->next 指向的就是最终链表的真正头节点（它可能是原始的 head，也可能是 head 后面的某个节点，如果原始 head 被删除了的话）。我们将这个结果赋给 head。
            
    - delete dummyHead;
        
        - 虚拟头节点已经完成了它的使命，它是一个临时创建的辅助节点，不属于原始数据。因此，必须将其内存释放掉。
            
    - return head;
        
        - 返回处理后链表的头节点。
            

#### 总结优势

- **逻辑统一**：避免了对头节点的特殊判断，使得删除逻辑对于链表中任何位置的节点都完全一样。
    
- **代码简洁**：减少了 if-else 分支，代码更易读、易维护。
    
- **健壮性**：能优雅地处理各种边界情况，例如链表为空、所有节点都需要被删除等。