```
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* temp; // 保存cur的下一个节点
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur) {
            temp = cur->next;  // 保存一下 cur的下一个节点，因为接下来要改变cur->next
            cur->next = pre; // 翻转操作
            // 更新pre 和 cur指针
            pre = cur;
            cur = temp;
        }
        return pre;
    }
};
```


我们来详细解析一下这段非常经典和高效的**反转链表的“双指针法”**代码。

你说的完全正确，这正是**双指针法**的典范应用。但更准确地说，为了实现它，我们其实用到了**三个指针**，它们各自扮演着至关重要的角色，像一个配合默契的小团队。

---

### 核心思想

这个算法的核心思想是**迭代 (Iteration)**。我们从头到尾遍历整个链表，在遍历的过程中，逐个地将每个节点的 `next` 指针**反向**，让它指向前一个节点。

### 指针角色分析

让我们来给三个指针起个好记的名字，理解它们的职责：

1.  `ListNode* pre = NULL;`
    *   **角色**：**前驱指针 (Previous Pointer)**。
    *   **职责**：它永远指向**已经反转好的那部分链表的头结点**。因为刚开始还没有任何节点被反转，所以它初始化为 `NULL` (空)。

2.  `ListNode* cur = head;`
    *   **角色**：**当前指针 (Current Pointer)**。
    *   **职责**：它指向**当前正要被操作（反转）的节点**。它像一个“工人”，负责在链表上向前移动。

3.  `ListNode* temp;`
    *   **角色**：**临时指针 (Temporary Pointer)**。
    *   **职责**：它是一个**“保险”**或**“备忘录”**。在 `cur` 节点的指针被反转之前，我们必须先用 `temp` **保存一下 `cur` 原来的下一个节点**，否则一旦 `cur->next` 的指向被修改，我们就会“丢失”后面还未处理的链表。

---

### 动画式分步解析

我们用一个简单的链表 `1 -> 2 -> 3 -> NULL` 作为例子，来一步步看代码是如何工作的。

**初始状态:**

*   `pre = NULL`
*   `cur` 指向节点 `1`
*   链表: `1 -> 2 -> 3 -> NULL`

  (想象一下这个状态)

---

#### `while` 循环第一次 (处理节点 1)

1.  `temp = cur->next;`
    *   保存 `cur` (节点1) 的下一个节点 `2`。
    *   现在 `temp` 指向 `2`。

2.  `cur->next = pre;`
    *   **【核心反转】**：将 `cur` (节点1) 的 `next` 指针指向 `pre` (当前是 `NULL`)。
    *   链表状态变为: `1 -> NULL`。节点 `2` 和 `3` 暂时“断开”了，但我们有 `temp` 记着它们。

3.  `pre = cur;`
    *   更新 `pre`。`pre` 向前移动，指向 `cur` (节点1)。
    *   现在 `pre` 指向了**已反转链表的头部** (目前是 `1`)。

4.  `cur = temp;`
    *   更新 `cur`。`cur` 向前移动，指向 `temp` (节点2)，准备处理下一个节点。

**第一次循环后状态:**

*   `pre` 指向 `1`
*   `cur` 指向 `2`
*   链表逻辑结构: `NULL <- 1   2 -> 3 -> NULL`

---

#### `while` 循环第二次 (处理节点 2)

1.  `temp = cur->next;`
    *   保存 `cur` (节点2) 的下一个节点 `3`。
    *   `temp` 指向 `3`。

2.  `cur->next = pre;`
    *   **【核心反转】**：将 `cur` (节点2) 的 `next` 指针指向 `pre` (当前是 `1`)。
    *   链表状态变为: `2 -> 1 -> NULL`。

3.  `pre = cur;`
    *   更新 `pre`，使其指向 `cur` (节点2)。
    *   `pre` 仍然是已反转链表的头部。

4.  `cur = temp;`
    *   更新 `cur`，使其指向 `temp` (节点3)。

**第二次循环后状态:**

*   `pre` 指向 `2`
*   `cur` 指向 `3`
*   链表逻辑结构: `NULL <- 1 <- 2   3 -> NULL`

---

#### `while` 循环第三次 (处理节点 3)

1.  `temp = cur->next;`
    *   保存 `cur` (节点3) 的下一个节点 `NULL`。
    *   `temp` 指向 `NULL`。

2.  `cur->next = pre;`
    *   **【核心反转】**：将 `cur` (节点3) 的 `next` 指针指向 `pre` (当前是 `2`)。
    *   链表状态变为: `3 -> 2 -> 1 -> NULL`。

3.  `pre = cur;`
    *   更新 `pre`，使其指向 `cur` (节点3)。

4.  `cur = temp;`
    *   更新 `cur`，使其指向 `temp` (当前是 `NULL`)。

**第三次循环后状态:**

*   `pre` 指向 `3`
*   `cur` 指向 `NULL`
*   链表逻辑结构: `NULL <- 1 <- 2 <- 3`

---

### 循环结束

现在 `cur` 的值是 `NULL`，`while(cur)` 条件不满足，循环终止。

### 返回结果

`return pre;`

*   此时 `pre` 指向哪个节点？**节点 `3`**。
*   节点 `3` 正是**反转后新链表的头结点**。

所以，函数正确地返回了新链表的头。

### 总结

这段代码的精髓在于，在循环的每一步，它都完美地做了三件事：
1.  用 `temp` **“备份”** 后面的路。
2.  用 `cur->next = pre` **“反转”** 当前的指针。
3.  用 `pre = cur` 和 `cur = temp` **“前进”**，为下一次反转做准备。