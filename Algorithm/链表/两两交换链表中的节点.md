```
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; // 将虚拟头结点指向head，这样方便后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != nullptr && cur->next->next != nullptr) {
            ListNode* tmp = cur->next; // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;    // 步骤一
            cur->next->next = tmp;          // 步骤二
            cur->next->next->next = tmp1;   // 步骤三

            cur = cur->next->next; // cur移动两位，准备下一轮交换
        }
        ListNode* result = dummyHead->next;
        delete dummyHead;
        return result;
    }
};
```

这段代码的精髓在于**使用虚拟头结点（Dummy Node）** 和**一个 `cur` 指针作为前驱节点**，从而用一套统一的逻辑完成所有节点的交换。

### 核心思想

1.  **虚拟头结点 (Dummy Node)**: 为了避免对原始头结点的交换进行复杂的 `if` 判断，我们创建一个虚拟节点 `dummyHead`。让 `dummyHead->next` 指向真正的头 `head`。这样一来，原来的头节点就变成了 `dummyHead` 后面的一个普通节点，对它的操作就和对其他所有节点的操作一样了。

2.  **`cur` 指针**: 我们用一个指针 `cur` 来标记**每次要交换的那一对节点的前一个节点**。这是理解整个算法的关键。`cur` 的作用是帮助我们把交换后的子链表重新连接回主链表。

3.  **循环交换**: `cur` 指针不断向后移动，每次移动两步，在循环中重复交换 `cur` 后面的两个节点，直到链表末尾。

---

### 代码逐行解析与图解

我们以一个链表 `1 -> 2 -> 3 -> 4` 为例，来一步步看代码是如何执行的。

**初始状态:**

```cpp
ListNode* dummyHead = new ListNode(0); // 创建虚拟头结点
dummyHead->next = head;              // 连接到原始链表
ListNode* cur = dummyHead;           // cur 指针指向虚拟头结点
```

此时的链表结构如下：

```
cur
 |
 V
[dummy] -> [1] -> [2] -> [3] -> [4] -> null
```

---

### 进入 `while` 循环 (第一次)

`while(cur->next != nullptr && cur->next->next != nullptr)`

*   `cur->next` 是 `[1]`，不为 null。
*   `cur->next->next` 是 `[2]`，不为 null。
*   条件满足，进入循环。

**循环内部的交换逻辑：**

为了方便理解，我们给节点起个别名：
*   `cur` 指向 `[dummy]`
*   `node1` 是 `[1]` (`cur->next`)
*   `node2` 是 `[2]` (`cur->next->next`)
*   `node3` 是 `[3]` (`cur->next->next->next`)

**1. 记录临时节点:**

```cpp
ListNode* tmp = cur->next;             // tmp 指向 [1]
ListNode* tmp1 = cur->next->next->next; // tmp1 指向 [3]```

这两行非常重要，它们保存了 `node1` 和 `node3` 的位置。因为接下来的操作会改变 `next` 指针，如果不事先保存，我们就会丢失对这两个节点的引用。

当前状态：
```
           tmp           tmp1
            |             |
            V             V
[dummy] -> [1] -> [2] -> [3] -> [4] -> null
  ^
  |
 cur
```

**2. 核心交换三步曲:**

这三步是整个算法的核心，顺序不能错。

```cpp
cur->next = cur->next->next;    // 步骤一
```
**解释**: 将 `cur` 的 `next` 指针从 `[1]` 改为指向 `[2]`。也就是把 `[dummy]` 连接到 `[2]`。
**图示**:
```
     +------------------+
     |                  V
   [dummy]    [1] -> [2]    [3] -> [4] -> null
     ^                 ^
     |                 |
    cur               +----------- cur->next
```

```cpp
cur->next->next = tmp;          // 步骤二
```
**解释**: 将 `cur->next` (现在是`[2]`) 的 `next` 指针指向 `tmp` (也就是`[1]`)。
**图示**:
```
   [dummy] -> [2] -> [1]    [3] -> [4] -> null
               ^      |
               |      +----- next 指向 [2]，但这个链接很快会被覆盖
               +------------ cur->next
```

```cpp
cur->next->next->next = tmp1;   // 步骤三
```
**解释**: 将 `cur->next->next` (现在是`[1]`) 的 `next` 指针指向 `tmp1` (也就是`[3]`)。这一步把交换好的部分重新连接回链表的剩余部分。
**图示**:
```
   [dummy] -> [2] -> [1] -> [3] -> [4] -> null
```
至此，第一对节点的交换完成！

**3. 移动 `cur` 指针:**

```cpp
cur = cur->next->next; // cur移动两位，准备下一轮交换
```
**解释**: 当前 `cur->next->next` 指向的是 `[1]`。所以 `cur` 从 `[dummy]` 移动到了 `[1]`。这非常巧妙，因为 `[1]` 正好是下一对要交换的节点 (`[3]` 和 `[4]`) 的前一个节点。
**当前状态**:
```
             cur
              |
              V
[dummy] -> [2] -> [1] -> [3] -> [4] -> null
```

---

### 进入 `while` 循环 (第二次)

`while(cur->next != nullptr && cur->next->next != nullptr)`

*   `cur->next` 是 `[3]`，不为 null。
*   `cur->next->next` 是 `[4]`，不为 null。
*   条件满足，再次进入循环。

重复上述的**交换三步曲**和**移动`cur`指针**的操作，交换 `[3]` 和 `[4]`。

交换后链表变为：
```
[dummy] -> [2] -> [1] -> [4] -> [3] -> null
```
然后 `cur` 移动到 `[3]` 的位置。

---

### 循环结束

此时 `cur` 指向 `[3]`。
*   `cur->next` 是 `null`。
*   循环条件 `cur->next != nullptr` 不满足，循环终止。

---

### 返回结果

```cpp
ListNode* result = dummyHead->next; // 获取新链表的头节点，即 [2]
delete dummyHead;                   // 释放虚拟节点的内存，防止内存泄漏
return result;                      // 返回结果
```
最终返回的 `result` 指向 `[2]`，整个链表就是 `2 -> 1 -> 4 -> 3 -> null`。

### 总结

这个算法的优雅之处在于：

*   **虚拟头结点**：将对头结点的特殊操作转化为普通操作。
*   **`cur` 作为前驱节点**：始终保持 `cur` 在待交换对的前面，使得连接操作 (`cur->next = ...`) 非常清晰。
*   **固定的三步交换逻辑**：通过临时变量保存关键节点，然后用三行代码完成指针的重新指向，逻辑统一且高效。
*   **`cur` 的移动**：`cur = cur->next->next` 能够精准地将 `cur` 移动到下一次交换的正确位置。