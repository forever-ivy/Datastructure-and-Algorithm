```
class Solution {
public:
    void reverseString(vector<char>& s) {
        for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {
            swap(s[i],s[j]);
        }
    }
};
```

### 代码目标

该函数 `reverseString` 的目标是接收一个由字符组成的动态数组 `vector<char>`，并将其中的元素顺序完全颠倒。例如，输入 `['h', 'e', 'l', 'l', 'o']`，函数执行后，原数组应变为 `['o', 'l', 'l', 'e', 'h']`。

### 核心算法：双指针法 (Two-Pointer Approach)

这个实现采用了最标准、最高效的**双指针法**。其核心思想是：
1.  设置一个指针（`i`）指向字符串的**开头**。
2.  设置另一个指针（`j`）指向字符串的**末尾**。
3.  只要左指针 `i` 在右指针 `j` 的左边，就**交换**它们所指向的字符。
4.  然后将左指针向右移动一位，右指针向左移动一位，继续下一轮交换，直到两个指针相遇或交错。

---

### 代码逐行解析

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
```
*   `void reverseString(...)`: 定义了一个名为 `reverseString` 的函数，返回类型为 `void`，意味着它**不返回任何值**。它的工作方式是直接修改传入的参数。
*   `vector<char>& s`: 参数 `s` 是一个字符向量。关键在于 `&` 符号，它表示**引用传递 (pass-by-reference)**。这意味着函数操作的是调用者传入的**原始 `s` 向量本身**，而不是它的一个副本。这就是为什么函数可以“原地”修改字符串并且不需要返回任何东西。

```cpp
        for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) {
```
*   这是一个 `for` 循环，是整个算法的核心。我们来分解它的三个部分：
    1.  **初始化 (`int i = 0, j = s.size() - 1;`)**:
        *   `int i = 0`: 初始化**左指针 `i`**，让它指向向量的第一个元素（索引为 0）。
        *   `int j = s.size() - 1`: 初始化**右指针 `j`**，让它指向向量的最后一个元素。（如果 `size` 是 5，最后一个元素的索引是 4）。

    2.  **循环条件 (`i < s.size()/2;`)**:
        *   这是循环继续执行的条件。循环只需要进行到向量的**一半**即可。
        *   **为什么是一半？** 因为每一步我们都同时处理了开头和末尾的两个字符。当左指针 `i` 走完前半部分时，整个向量就已经被完全反转了。如果循环继续下去（例如 `i < j`），它会把已经换好的字符再换回去，等于什么都没做。
        *   对于奇数长度的字符串（如 "hello"），中间的字符（'l'）不需要移动，这个条件 `i < size/2` 恰好能保证它不被处理。

    3.  **迭代 (`i++, j--`)**:
        *   在每次循环结束后，执行这个部分。
        *   `i++`: 左指针向右移动一位。
        *   `j--`: 右指针向左移动一位。
        *   这样，两个指针就一步步地向数组的中心靠拢。

```cpp
            swap(s[i],s[j]);
        }
    }
};
```
*   `swap(s[i], s[j]);`: 这是循环体内部唯一的语句。
*   `s[i]`: 获取左指针指向的字符。
*   `s[j]`: 获取右指针指向的字符。
*   `swap(...)`: 这是 C++ 标准库中的一个函数，它会高效地交换传入的两个参数的值。在这里，它交换了首尾对应的两个字符。

---

### 举例说明

让我们用 `s = ['h', 'e', 'l', 'l', 'o']` 来手动走一遍流程：
*   **初始状态**:
    *   `s = ['h', 'e', 'l', 'l', 'o']`
    *   `i = 0`, `j = 4`
    *   `s.size()/2 = 2`

*   **第 1 次循环**:
    *   **条件**: `i < 2` (即 `0 < 2`)，为 `true`。
    *   **执行**: `swap(s[0], s[4])`，即交换 `'h'` 和 `'o'`。
    *   **结果**: `s` 变为 `['o', 'e', 'l', 'l', 'h']`。
    *   **迭代**: `i` 变为 1，`j` 变为 3。

*   **第 2 次循环**:
    *   **条件**: `i < 2` (即 `1 < 2`)，为 `true`。
    *   **执行**: `swap(s[1], s[3])`，即交换 `'e'` 和 `'l'`。
    *   **结果**: `s` 变为 `['o', 'l', 'l', 'e', 'h']`。
    *   **迭代**: `i` 变为 2，`j` 变为 2。

*   **第 3 次循环**:
    *   **条件**: `i < 2` (即 `2 < 2`)，为 `false`。
    *   **循环终止**。

函数执行完毕，`s` 已经被成功地原地反转为 `['o', 'l', 'l', 'e', 'h']`。

### 算法分析

*   **时间复杂度**: O(N)，其中 N 是字符串的长度。因为我们大约遍历了字符串的一半，所以操作次数与 N 成正比。
*   **空间复杂度**: O(1)。因为我们没有使用任何额外的、随字符串大小而增长的数据结构。交换是在原地进行的，只使用了几个固定的指针变量。这是最优的空间效率。