```
#include <iostream>
using namespace std;
int main() {
    string s;
    while (cin >> s) {
        int sOldIndex = s.size() - 1;
        int count = 0; // 统计数字的个数
        for (int i = 0; i < s.size(); i++) {
            if (s[i] >= '0' && s[i] <= '9') {
                count++;
            }
        }
        // 扩充字符串s的大小，也就是将每个数字替换成"number"之后的大小
        s.resize(s.size() + count * 5);
        int sNewIndex = s.size() - 1;
        // 从后往前将数字替换为"number"
        while (sOldIndex >= 0) {
            if (s[sOldIndex] >= '0' && s[sOldIndex] <= '9') {
                s[sNewIndex--] = 'r';
                s[sNewIndex--] = 'e';
                s[sNewIndex--] = 'b';
                s[sNewIndex--] = 'm';
                s[sNewIndex--] = 'u';
                s[sNewIndex--] = 'n';
            } else {
                s[sNewIndex--] = s[sOldIndex];
            }
            sOldIndex--;
        }
        cout << s << endl;       
    }
}
```



### 代码目标

这段代码的核心目标是：**读取一个字符串，将其中的每一个数字字符（'0' 到 '9'）替换成单词 "number"，并且这个替换过程要求在原地完成，即不使用额外的字符串数组作为辅助空间。**

**例如：**
*   输入: `a1b2c`
*   输出: `anumberbnumberc`

### 核心算法思想：空间预留 + 双指针从后向前填充

直接从前向后替换是行不通的。比如 `a1b2c`，当你把 `'1'` 替换成 "number" 时，字符串变成了 `anumber...`，这会覆盖掉后面的 `'b'`, `'2'`, `'c'`。

因此，代码采用了一种非常聪明的两步走策略：

1.  **第一步：计算并预留空间**
    *   先遍历一次字符串，统计出里面有多少个数字。
    *   根据数字的个数，计算出最终字符串需要的总长度（原长度 + 数字个数 * ( "number"的长度 - 数字'1'的长度 )）。
    *   使用 `s.resize()` 将字符串的容量一次性扩大到最终需要的尺寸。这样，我们就获得了足够的“空闲空间”来存放替换后的内容。

2.  **第二步：双指针从后向前填充**
    *   设置一个指针 `sOldIndex` 指向**原字符串的末尾**。
    *   设置另一个指针 `sNewIndex` 指向**新（扩容后）字符串的末尾**。
    *   同时从后向前移动这两个指针，进行填充：
        *   如果 `sOldIndex` 指向的字符**不是**数字，就直接把它复制到 `sNewIndex` 的位置，然后两个指针都向前移动一位。
        *   如果 `sOldIndex` 指向的字符**是**数字，那么 `sOldIndex` 只向前移动一位，而 `sNewIndex` 则要向前移动六位，并在这六个位置上依次填入 "number" 的倒序 "r", "e", "b", "m", "u", "n"。

**为什么从后向前？**
因为从后向前填充，新填入的内容（"number"）会被放在字符串的末尾区域，而这个区域是我们刚刚 `resize` 出来的空闲空间。这样就**永远不会覆盖掉**前面尚未处理的原始字符。

---

### 代码逐行解析

```cpp
#include <iostream>
using namespace std;
int main() {
    string s;
    while (cin >> s) { // 循环读取输入的字符串
```
*   标准的 C++ 输入输出设置。`while (cin >> s)` 允许多次输入测试。

```cpp
        // 第一步：计算并预留空间
        int sOldIndex = s.size() - 1; // 临时记录一下旧的末尾索引
        int count = 0; // 统计数字的个数
        for (int i = 0; i < s.size(); i++) {
            if (s[i] >= '0' && s[i] <= '9') {
                count++;
            }
        }
```
*   `count` 用于统计字符串中数字字符的数量。

```cpp
        // 扩充字符串s的大小
        s.resize(s.size() + count * 5);
```
*   **这是空间预留的关键**。
*   每个数字（占 1 个字符）要被替换成 "number"（占 6 个字符），净增长是 `6 - 1 = 5` 个字符。
*   所以，总共需要增加的长度就是 `count * 5`。
*   `s.resize()` 将字符串 `s` 的内部存储空间扩大，后面多出来的部分是未定义的，等待我们去填充。

```cpp
        // 第二步：双指针从后向前填充
        int sNewIndex = s.size() - 1;
        // sOldIndex 之前已经计算过，这里重新从原字符串末尾开始
        // 注意：此时 s.size() 已经是扩容后的大小了，所以不能再用它来初始化 sOldIndex
        // (代码在这里复用了之前的 sOldIndex 变量，是正确的)
```
*   `sNewIndex`: 指向扩容后字符串的最后一个位置。
*   `sOldIndex`: 指向原字符串的最后一个位置。

```cpp
        while (sOldIndex >= 0) {
```
*   循环直到把原字符串的所有字符都处理完。

```cpp
            if (s[sOldIndex] >= '0' && s[sOldIndex] <= '9') {
                s[sNewIndex--] = 'r';
                s[sNewIndex--] = 'e';
                s[sNewIndex--] = 'b';
                s[sNewIndex--] = 'm';
                s[sNewIndex--] = 'u';
                s[sNewIndex--] = 'n';
            }
```
*   **处理数字字符**:
    *   如果 `s[sOldIndex]` 是一个数字。
    *   就在 `sNewIndex` 指向的位置开始，倒着填入 "number"。
    *   `s[sNewIndex--] = 'r';` 这句代码的意思是：先把 `'r'` 存入 `s[sNewIndex]`，然后 `sNewIndex` 的值减一。
    *   依次执行六次，就完成了 "number" 的填充，并且 `sNewIndex` 也正确地向前移动了 6 个位置。

```cpp
            else {
                s[sNewIndex--] = s[sOldIndex];
            }
```
*   **处理非数字字符**:
    *   如果 `s[sOldIndex]` 不是数字，就直接把它“搬运”到 `sNewIndex` 的位置。
    *   然后 `sNewIndex` 和 `sOldIndex` 都需要向前移动。

```cpp
            sOldIndex--;
        }
```
*   无论 `if` 还是 `else` 分支被执行，`sOldIndex` 每次循环都必须向前移动一位，以处理下一个原始字符。

```cpp
        cout << s << endl;       
    }
}
```
*   循环结束后，`s` 中就已经包含了替换完成的最终结果，将其输出。

### 算法分析

*   **时间复杂度**: O(N)，其中 N 是原字符串的长度。因为代码中有两次独立的、线性的遍历（一次统计，一次填充）。
*   **空间复杂度**: O(1)。虽然我们用 `resize` 扩大了字符串，但这是在**原地修改**，没有使用与输入规模 N 线性相关的**额外**数据结构。这被认为是 O(1) 的空间复杂度。