```
class MyQueue {
public:
    stack<int> stIn;
    stack<int> stOut;
    /** Initialize your data structure here. */
    MyQueue() {

    }
    /** Push element x to the back of queue. */
    void push(int x) {
        stIn.push(x);
    }

    /** Removes the element from in front of queue and returns that element. */
    int pop() {
        // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
        if (stOut.empty()) {
            // 从stIn导入数据直到stIn为空
            while(!stIn.empty()) {
                stOut.push(stIn.top());
                stIn.pop();
            }
        }
        int result = stOut.top();
        stOut.pop();
        return result;
    }

    /** Get the front element. */
    int peek() {
        int res = this->pop(); // 直接使用已有的pop函数
        stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去
        return res;
    }

    /** Returns whether the queue is empty. */
    bool empty() {
        return stIn.empty() && stOut.empty();
    }
};
```

这段代码实现了一个使用两个栈 `stIn` 和 `stOut` 来模拟队列操作的 `MyQueue` 类。

我们知道，队列的特点是“先进先出”（FIFO），而栈的特点是“先进后出”（LIFO）。使用两个栈来模拟队列，其核心思想是：

*   **`stIn` 栈用于入队（push）操作：** 所有新入队的元素都直接压入 `stIn` 栈。
*   **`stOut` 栈用于出队（pop）和查看队头（peek）操作：** 当需要出队或查看队头元素时，如果 `stOut` 不为空，则直接从 `stOut` 中弹出或查看。如果 `stOut` 为空，则需要将 `stIn` 中的所有元素“倒”到 `stOut` 中，这样 `stIn` 中最底部的元素（也就是最先入队的元素）就会在 `stOut` 的顶部，从而实现队列的 FIFO 特性。

下面我们逐个函数进行解释：

### `MyQueue()` 构造函数

```cpp
MyQueue() {
    // 两个栈在创建时自动初始化
}
```

这是一个默认构造函数。当 `MyQueue` 对象被创建时，它的两个内部栈 `stIn` 和 `stOut` 也会被自动初始化为空栈。这里不需要额外的代码。

### `void push(int x)` 入队操作

```cpp
void push(int x) {
    stIn.push(x);
}
```

*   **逻辑：** 非常简单直观。当一个元素 `x` 需要入队时，直接将其压入 `stIn` 栈。
*   **思考：** `stIn` 负责接收所有新进来的元素。此时，元素的顺序是按照入队顺序从上到下排列的。例如，如果按 1, 2, 3 的顺序入队，`stIn` 的栈底是 1，栈顶是 3。

### `int pop()` 出队操作

```cpp
int pop() {
    // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）
    if (stOut.empty()) {
        // 从stIn导入数据直到stIn为空
        while(!stIn.empty()) {
            stOut.push(stIn.top());
            stIn.pop();
        }
    }
    int result = stOut.top();
    stOut.pop();
    return result;
}
```

*   **逻辑：**
    1.  **检查 `stOut`：** 首先判断 `stOut` 栈是否为空。
        *   **如果 `stOut` 不为空：** 这说明 `stOut` 中已经有元素可以用于出队。这些元素是之前从 `stIn` 转移过来的，并且它们已经按照队列的 FIFO 顺序排列好了。所以，直接从 `stOut` 的栈顶弹出元素即可。
        *   **如果 `stOut` 为空：** 这意味着当前 `stOut` 无法提供出队元素。此时，所有队列中的元素都在 `stIn` 栈中。为了实现 FIFO，我们需要将 `stIn` 中的元素全部转移到 `stOut` 中。这个转移过程会将 `stIn` 中最先入队的元素（即 `stIn` 的栈底元素）放到 `stOut` 的栈顶。
            *   `while(!stIn.empty())` 循环：不断地将 `stIn` 的栈顶元素弹出，并压入 `stOut`。
    2.  **获取结果并弹出：** 经过上述处理，`stOut` 栈的顶部元素一定是当前队列的队头元素。将其赋值给 `result`，然后从 `stOut` 中弹出，并返回 `result`。

*   **思考：** `stOut` 栈的作用是“反转” `stIn` 栈中元素的顺序。当 `stIn` 中的元素被逐个弹出并压入 `stOut` 时，它们就颠倒了顺序。例如，如果 `stIn` 中是 [1, 2, 3]（栈底到栈顶），转移后 `stOut` 中就是 [3, 2, 1]（栈底到栈顶），此时 `stOut` 的栈顶就是 1，正是队列的队头。
    *   **重要优化：** 只有当 `stOut` 为空时才进行转移操作。这样做可以避免不必要的元素转移，提高效率。如果在 `stOut` 还有元素的情况下频繁进行转移，会增加操作的开销。

### `int peek()` 查看队头元素

```cpp
int peek() {
    int res = this->pop(); // 直接使用已有的pop函数
    stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去
    return res;
}
```

*   **逻辑：**
    1.  **利用 `pop()`：** `peek()` 操作需要获取队头元素，但不能将其从队列中移除。巧妙地利用了 `pop()` 函数。调用 `this->pop()` 会获取到队头元素，并将其从 `stOut` 中移除。
    2.  **恢复元素：** 由于 `pop()` 会移除元素，为了 `peek()` 不改变队列状态的语义，需要将刚刚弹出的元素 `res` 重新压回 `stOut` 栈。
    3.  **返回结果：** 返回 `res`。

*   **思考：** 这种实现方式非常简洁，复用了 `pop` 的逻辑。缺点是多了一次 `push` 操作，但对于 `peek` 的功能来说，这是必要的。
    *   **另一种实现方式（更直接）：** 也可以直接复制 `pop` 函数中获取队头元素的部分：
        ```cpp
        int peek() {
            if (stOut.empty()) {
                while(!stIn.empty()) {
                    stOut.push(stIn.top());
                    stIn.pop();
                }
            }
            return stOut.top();
        }
        ```
        这种方式避免了额外的 `push` 操作，可能更优。原代码使用 `pop()` 再 `push()` 也是可行的，但需要理解其背后的操作。

### `bool empty()` 判断队列是否为空

```cpp
bool empty() {
    return stIn.empty() && stOut.empty();
}
```

*   **逻辑：** 队列为空当且仅当两个栈 `stIn` 和 `stOut` 都为空。
*   **思考：** 如果 `stIn` 非空而 `stOut` 为空，说明有元素在 `stIn` 中等待被转移，队列是非空的。反之亦然。只有当两个栈都完全没有元素时，队列才是空的。

### 总结图示 (非代码)

为了更好地理解，可以想象下面的流程：

1.  **Push 1, 2, 3：**
    `stIn`: [1(bottom), 2, 3(top)]
    `stOut`: []

2.  **Pop (stOut为空，转移stIn到stOut)：**
    `stIn`: []
    `stOut`: [3(bottom), 2, 1(top)]
    Pop 1.
    `stOut`: [3(bottom), 2(top)]
    返回 1。

3.  **Push 4：**
    `stIn`: [4(top)]
    `stOut`: [3(bottom), 2(top)]

4.  **Peek (stOut不为空，直接看stOut顶部，然后恢复)：**
    `stOut`: [3(bottom), 2(top)]
    `pop()` 会弹 2。
    `stOut`: [3(top)]
    再 `push()` 2回去。
    `stOut`: [3(bottom), 2(top)]
    返回 2。

这个实现有效地利用了栈的 LIFO 特性来模拟队列的 FIFO 特性，是数据结构中一个经典的面试题和实现方法。
