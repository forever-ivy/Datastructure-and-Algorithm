```
class MyStack {
public:
    queue<int> que;

    MyStack() {

    }

    void push(int x) {
        que.push(x);
    }

    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }

    int top(){
        int size = que.size();
        size--;
        while (size--){
            // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时获得的元素就是栈顶的元素了
        que.push(que.front());    // 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化
        que.pop();
        return result;
    }

    bool empty() {
        return que.empty();
    }
};
```

这段代码实现了一个使用一个队列 `que` 来模拟栈操作的 `MyStack` 类。

我们知道，栈的特点是“先进后出”（LIFO），而队列的特点是“先进先出”（FIFO）。使用一个队列来模拟栈，其核心思想是：

*   **`push` 操作：** 直接将元素入队。
*   **`pop` 和 `top` 操作：** 这是关键。由于队列是 FIFO，新入队的元素总是在队列的尾部。为了模拟栈的 LIFO 特性（即最后入队的元素最先出队），在进行 `pop` 或 `top` 操作时，需要将队列中除了最后一个元素之外的所有元素都重新排到队列的尾部。这样，原来队列中的最后一个元素（也就是最近 `push` 进来的元素）就变成了队列的头部，可以被 `pop` 或 `top` 访问。

下面我们逐个函数进行解释：

### `MyStack()` 构造函数

```cpp
MyStack() {
    // 队列在创建时自动初始化
}
```

这是一个默认构造函数。当 `MyStack` 对象被创建时，其内部的 `queue<int> que` 会被自动初始化为空队列。这里不需要额外的代码。

### `void push(int x)` 入栈操作

```cpp
void push(int x) {
    que.push(x);
}
```

*   **逻辑：** 非常简单直观。当一个元素 `x` 需要入栈时，直接将其添加到队列 `que` 的尾部。
*   **思考：** 此时，队列中元素的顺序是按照入栈顺序排列的。例如，如果按 1, 2, 3 的顺序入栈，队列中就是 [1, 2, 3]（队头是 1，队尾是 3）。这里的 3 是栈顶元素，但它在队列的尾部。

### `int pop()` 出栈操作

```cpp
int pop() {
    int size = que.size();
    size--; // 标记需要移动的元素数量，即除了最后一个元素外的所有元素
    while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
        que.push(que.front()); // 将队头元素移动到队尾
        que.pop();             // 移除原来的队头元素
    }
    int result = que.front(); // 此时队头就是栈顶元素
    que.pop();                // 将栈顶元素从队列中移除
    return result;
}
```

*   **逻辑：**
    1.  **获取队列大小并计算移动次数：** `int size = que.size();` 获取当前队列的元素数量。`size--` 是因为我们希望留下队列中的最后一个元素（它对应栈顶元素），其他 `size-1` 个元素需要移动。
    2.  **循环移动元素：**
        *   `while (size--)` 循环会执行 `que.size() - 1` 次。
        *   在每次循环中，`que.push(que.front());` 将当前的队头元素添加到队列的尾部。
        *   `que.pop();` 将原来的队头元素移除。
        *   **效果：** 经过 `size-1` 次这样的操作，队列中除了最初的最后一个元素之外的所有元素都被移动到了队尾。此时，最初的最后一个元素（也就是最近 `push` 进来的元素，即栈顶元素）现在变成了队列的队头。
    3.  **获取并移除栈顶元素：** `int result = que.front();` 获取当前队头元素（即栈顶元素）。`que.pop();` 将其从队列中移除。
    4.  **返回结果：** 返回 `result`。

*   **思考：** 这个操作的核心在于“旋转”队列。如果队列是 [1, 2, 3]（栈顶是 3），`pop()` 会将 1 移到队尾，队列变为 [2, 3, 1]。然后将 2 移到队尾，队列变为 [3, 1, 2]。此时，3 就在队头，可以直接弹出。

### `int top()` 获取栈顶元素

```cpp
int top(){
    int size = que.size();
    size--; // 标记需要移动的元素数量，即除了最后一个元素外的所有元素
    while (size--){
        // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
        que.push(que.front());
        que.pop();
    }
    int result = que.front(); // 此时获得的元素就是栈顶的元素了
    que.push(que.front());    // 将获取完的元素也重新添加到队列尾部，保证数据结构没有变化
    que.pop();
    return result;
}
```

*   **逻辑：** `top()` 操作和 `pop()` 操作非常相似，主要区别在于 `top()` 不应该移除元素，而只是返回栈顶元素。
    1.  **移动元素：** 前面部分的 `int size = que.size(); size--; while (size--) { ... }` 和 `pop()` 函数完全相同。它的作用是将栈顶元素移动到队列的队头。
    2.  **获取栈顶元素：** `int result = que.front();` 此时 `que.front()` 就是栈顶元素。
    3.  **恢复队列：** **这是与 `pop()` 最重要的区别。** `top()` 不应改变队列的状态。因此，在获取到 `que.front()` 之后，需要再次执行 `que.push(que.front());` 和 `que.pop();`。
        *   `que.push(que.front());