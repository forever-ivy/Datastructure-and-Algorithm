
【题目描述】

在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。

现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。

然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。

为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。

注意：区块不可再分。

【输入描述】

第一行输入两个正整数，代表 n 和 m。

接下来的 n 行，每行输出 m 个正整数。

输出描述

请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

【输入示例】

3 3 1 2 3 2 1 3 1 2 3

【输出示例】

0

【提示信息】

如果将区域按照如下方式划分：

1 2 | 3 2 1 | 3 1 2 | 3

两个子区域内土地总价值之间的最小差距可以达到 0。

【数据范围】：

- 1 <= n, m <= 100；
- n 和 m 不同时为 1。




```
#include <iostream>
#include <vector>
#include <climits>

using namespace std;
int main () {
    int n, m;
    cin >> n >> m;
    int sum = 0;
    vector<vector<int>> vec(n, vector<int>(m, 0)) ;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> vec[i][j];
            sum += vec[i][j];
        }
    }

    int result = INT_MAX;
    int count = 0; // 统计遍历过的行
    for (int i = 0; i < n; i++) {
        for (int j = 0 ; j < m; j++) {
            count += vec[i][j];
            // 遍历到行末尾时候开始统计
            if (j == m - 1) result = min (result, abs(sum - count - count));

        }
    }

    count = 0; // 统计遍历过的列
    for (int j = 0; j < m; j++) {
        for (int i = 0 ; i < n; i++) {
            count += vec[i][j];
            // 遍历到列末尾的时候开始统计
            if (i == n - 1) result = min (result, abs(sum - count - count));
        }
    }
    cout << result << endl;
}
 
```


### 代码解析：模拟所有切分方案

这段 C++ 代码的目的是解决一个二维区域划分问题。它通过一种直接、清晰的**模拟**方法，计算了所有可能的**横向**和**纵向**切分方案，并从中找出了最优解。

#### 核心思想：遍历所有可能的“一刀切”

题目规定，区域只能被横向或纵向切割一次，形成两个子区域。这意味着，可能的切分线只有 (n-1) 条水平线和 (m-1) 条垂直线。该算法的核心就是：

1. 计算出整个区域的土地总价值 sum。
    
2. **模拟所有横向切分**：逐行累加，计算每一种横向切分（切在第 i 行之后）所形成的上方子区域的价值，然后利用总价值 sum 推算出下方子区域的价值，并计算两者的差值。
    
3. **模拟所有纵向切分**：逐列累加，计算每一种纵向切分（切在第 j 列之后）所形成的左方子区域的价值，然后推算出右方子区域的价值，并计算差值。
    
4. 在所有这些差值中，找到最小值。
    

#### 代码执行流程

1. **阶段一：初始化与数据读取**
    
    - cin >> n >> m;：读取矩阵的维度。
        
    - vector<vector<int>> vec(n, vector<int>(m, 0));：创建 n x m 的二维数组。
        
    - int sum = 0;：初始化总价值为 0。
        
    - 第一个双重 for 循环：
        
        - cin >> vec[i][j];：读取每个区块的价值。
            
        - sum += vec[i][j];：在读取数据的同时，高效地计算出所有区块的总价值 sum。
            
2. **阶段二：模拟所有横向切分**
    
    - int result = INT_MAX;：初始化最小差值为整型的最大值，以便任何计算出的差值都比它小。
        
    - int count = 0;：count 在这里用作一个**累加器**，用于计算切分线一侧的区域总价值。
        
    - 第二个双重 for 循环（按行遍历）：
        
        - 外层循环 for (int i = 0; i < n; i++) 遍历每一行。
            
        - 内层循环 for (int j = 0; j < m; j++) 累加当前行的所有价值到 count 中。
            
        - 当内层循环结束时（j == m - 1），count 的值就等于从第 0 行到当前第 i 行的所有区块的总价值。这正好代表了一个**横向切分**方案中，**上方子区域**的总价值。
            
        - result = min(result, abs(sum - count - count));：这是计算差值的关键。
            
            - 如果上方区域价值为 count。
                
            - 那么下方区域价值就是 sum - count。
                
            - 两者之差的绝对值为 abs(count - (sum - count))，化简后即为 abs(2 * count - sum)，也就是代码中的 abs(sum - count - count)。
                
            - min 函数会保留目前为止找到的最小差值。
                
3. **阶段三：模拟所有纵向切分**
    
    - count = 0;：重置累加器，准备计算纵向切分。
        
    - 第三个双重 for 循环（按列遍历）：
        
        - 这个循环的内外层顺序与上一个不同，外层循环 for (int j = 0; j < m; j++) 遍历每一列。
            
        - 当外层循环执行到第 j 列时，内层循环会把这一整列的价值累加到 count 中。
            
        - 因此，当外层循环的第 j 次迭代结束时，count 的值就等于从第 0 列到当前第 j 列的所有区块的总价值。这代表了一个**纵向切分**方案中，**左方子区域**的总价值。
            
        - 同样，使用 result = min(result, abs(sum - count - count)); 来计算并更新最小差值。
            
4. **阶段四：输出结果**
    
    - cout << result << endl;：在遍历完所有可能的横向和纵向切分后，result 中存储的就是最小的价值差，将其输出。
        

#### 示例追踪 (输入 3 3 和矩阵)

1. **初始化**: sum 被计算为 1+2+3+2+1+3+1+2+3 = 18。result 为 INT_MAX。
    
2. **横向切分**:
    
    - i=0: 累加第 0 行，count = 1+2+3 = 6。差值 abs(18 - 2*6) = 6。result 更新为 6。
        
    - i=1: 累加第 1 行，count = 6 + (2+1+3) = 12。差值 abs(18 - 2*12) = 6。result 仍为 6。
        
    - i=2: 累加第 2 行，count = 12 + (1+2+3) = 18。差值 abs(18 - 2*18) = 18。result 不变。
        
3. **纵向切分**:
    
    - count 重置为 0。
        
    - j=0: 累加第 0 列，count = 1+2+1 = 4。差值 abs(18 - 2*4) = 10。result 不变。
        
    - j=1: 累加第 1 列，count = 4 + (2+1+2) = 9。差值 abs(18 - 2*9) = 0。result 更新为 **0**。
        
    - j=2: 累加第 2 列，count = 9 + (3+3+3) = 18。差值 abs(18 - 2*18) = 18。result 不变。
        
4. **输出**: 最终 result 的值为 0。
    

该算法虽然看起来有多个双重循环，但其本质是线性扫描，时间复杂度为 O(n*m)，对于题目给定的数据范围是完全足够高效的。