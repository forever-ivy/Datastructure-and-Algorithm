```
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int result = INT32_MAX;
        int sum = 0; // 滑动窗口数值之和
        int i = 0; // 滑动窗口起始位置
        int subLength = 0; // 滑动窗口的长度
        for (int j = 0; j < nums.size(); j++) {
            sum += nums[j];
            // 注意这里使用while，每次更新 i（起始位置），并不断比较子序列是否符合条件
            while (sum >= s) {
                subLength = (j - i + 1); // 取子序列的长度
                result = result < subLength ? result : subLength;
                sum -= nums[i++]; // 这里体现出滑动窗口的精髓之处，不断变更i（子序列的起始位置）
            }
        }
        // 如果result没有被赋值的话，就返回0，说明没有符合条件的子序列
        return result == INT32_MAX ? 0 : result;
    }
};
```

### 代码解析：滑动窗口

这段 C++ 代码解决的是一个经典问题：在一个正整数数组 nums 中，寻找一个**连续子数组**，使得其和**大于或等于**给定的目标值 s，并返回该子数组的**最小可能长度**。如果不存在这样的子数组，则返回 0。

该解法优于暴力枚举（暴力法通常需要两层循环），它采用了一种非常高效的算法思想——**滑动窗口**。

#### 核心思想：滑动窗口

滑动窗口可以被想象成一个在数组上移动的窗口。[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQE8yWVybYhrKe4WBdMH87yDJx0E6rMo5WQDdcGreXD5E8pUIHfiOEaRGI8qAMVUoaEdELF_MsYwUtG60dG2D8V50PHhwXnolAnA1IHcrD2_hWmLS-E0szcUmEi1XNjwsN1p3P2izmj8tjKQjYg4PVCCZIuAzLZN)][[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEn-Px3wq2LtRiv7LOzsnO6daqFKA1Ldzzvp2ciwsJJuuUiCyqxheVh-LqyEaCVOnF5KZlBQiw2tAH4qCbF0f4g05v82zdy5Oa7KoY4mph53QLs4FN_-iA4Ih7Xqbv8PzP8HiBldu0EWOR_VSTAXGq43eMCbp0%3D)][[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFbg8ljPpkR8o5a8EUhe7q5soguarlAt6zN8kpqf5gKB60OlfDEF5x1OaKdNIfxjedu0nfdwJQfXF4e9RRn8goBEaboXVIGXnQnyakKv-rjgzBrLNSM4_IDgBtZ70jBRrAzpE6pZA%3D%3D)] 这个窗口的大小不是固定的，而是**动态变化的**。[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFsfZNtBTBlT-pLLFb42hcr2wyH1mzrwNCHYdpamGmUmIi7DuKnFa4JZ1VRIcVi4CD4cFXsdRqiODUD_Wwd5Zv2jQdfdVKjHl4PycXuOTxacmMaieQywfAmsItZC6V8Pn24iBFbRC8oELvPmf0PaYWbE0F002PLDdfG0CfkeHvXpi8zXo1AxQoZ-UN3)] 算法的核心在于通过移动窗口的左右边界，来高效地探索所有可能的连续子数组，从而避免了不必要的重复计算。[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQE8yWVybYhrKe4WBdMH87yDJx0E6rMo5WQDdcGreXD5E8pUIHfiOEaRGI8qAMVUoaEdELF_MsYwUtG60dG2D8V50PHhwXnolAnA1IHcrD2_hWmLS-E0szcUmEi1XNjwsN1p3P2izmj8tjKQjYg4PVCCZIuAzLZN)]

这个算法主要包含两个步骤：

1. **扩展窗口**：不断向右移动窗口的右边界（j 指针），将新元素包含进来，并累加它们的和 sum。
    
2. **收缩窗口**：一旦窗口内元素的和 sum 满足了条件（>= s），就尝试从左侧收缩窗口（移动左边界 i 指针），以寻找是否能得到一个更短的、但仍然满足条件的子数组。
    

通过这种一进一出的方式，窗口在数组上“滑动”，最终找到最优解。[[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEQ4D_g8f8MRywN0BC4g8fkH1Nglyyt6hpo38NQ5lUSORbac0lX0uakGfm1wrc_UdSeYi7c5wmPiYkXHjf-eujpjo5LIytOVWZCNdVLwgTdTouCC-L0hkjhxzbW03XOnj1r3FaEmQxmi85pUhCbtbOxHU9rjFvm)]

#### 代码执行流程

1. **初始化**：
    
    - result = INT32_MAX;：初始化结果为一个非常大的数。这是为了方便后续比较，确保任何有效的子数组长度都会比它小。
        
    - sum = 0;：当前窗口内所有元素的和。
        
    - i = 0;：窗口的**起始位置**（左指针）。
        
    - subLength = 0;：当前窗口的长度。
        
2. **扩展窗口（外层循环）**：
    
    - for (int j = 0; j < nums.size(); j++)：j 是窗口的**结束位置**（右指针）。这个循环控制窗口不断向右扩展。
        
    - sum += nums[j];：将右指针 j 指向的新元素加入到窗口的和 sum 中。
        
3. **收缩窗口（内层 while 循环）**：
    
    - while (sum >= s)：这是整个算法的精髓。一旦窗口内的和 sum 达到了目标值 s，就进入这个循环。
        
    - **更新结果**：
        
        - subLength = (j - i + 1);：计算当前满足条件的窗口的长度。
            
        - result = result < subLength ? result : subLength;：将当前长度与已记录的最小长度 result 比较，并保留较小者。
            
    - **窗口左移**：
        
        - sum -= nums[i++];：为了寻找更短的子数组，需要将窗口的左边界向右移动。这一步操作包含两个动作：
            
            1. sum -= nums[i]：从 sum 中减去最左边的元素值。
                
            2. i++：将左指针 i 向右移动一位。
                
    - while 循环会持续进行，直到 sum < s，意味着再继续收缩窗口就不满足条件了。此时，外层循环的 j 会继续向右移动，以扩展窗口，寻找新的可能性。
        
4. **返回最终结果**：
    
    - 循环结束后，如果 result 仍然是 INT32_MAX，说明在整个过程中，没有任何子数组的和能达到 s。在这种情况下，返回 0。
        
    - 否则，返回记录下的最小长度 result。
        

#### 举例说明

假设 s = 7, nums = [2, 3, 1, 2, 4, 3]

|   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|
|j|i|nums[j]|sum (窗口内和)|sum >= 7?|操作|result|
|0|0|2|2|false||INT_MAX|
|1|0|3|5|false||INT_MAX|
|2|0|1|6|false||INT_MAX|
|3|0|2|8|true|subLength=4, result=4; sum-=nums, i=1 (sum=6)|4|
|4|1|4|10|true|subLength=4, result=4; sum-=nums[[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHQohctOIMvk8cMdXdqHWkY8mgg-mwLS--juxP-ZPXiBeRiKRlTIPBTe9h42wW2TTiqSXl83l2xd3ZHhjU8UvRlVqppTU2x9ZFkMvhVG0uCRG5fdL7OlfeJXdnOgWeDQjU2lDff86zg0VxSW-YLznH8Ot8iYg%3D%3D)], i=2 (sum=7)|4|
||2||7|true|subLength=3, result=3; sum-=nums[[7](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHW1O94WTYcKLrI6K_DQ33MDH-GANpp-aGoS4J1h3qpbpF67fNI-MaflYAsypOsT3llKVMYEoqeG-hYVTmIK4ZIpu_6Q5rkiuCjbZGiLdP15i0ajPfvjIf_mPZMJ2WSQVkUYRnwQn9tGoV3nwEvBJSSXGFMHU1X)], i=3 (sum=6)|3|
|5|3|3|9|true|subLength=3, result=3; sum-=nums[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFsfZNtBTBlT-pLLFb42hcr2wyH1mzrwNCHYdpamGmUmIi7DuKnFa4JZ1VRIcVi4CD4cFXsdRqiODUD_Wwd5Zv2jQdfdVKjHl4PycXuOTxacmMaieQywfAmsItZC6V8Pn24iBFbRC8oELvPmf0PaYWbE0F002PLDdfG0CfkeHvXpi8zXo1AxQoZ-UN3)], i=4 (sum=7)|3|
||4||7|true|subLength=2, result=2; sum-=nums[[8](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFRAuNIVbfZ_NxiEJDhBZ6AENH8a6yB2B1BAX_O46A50TdetwwhVR_GmF6ULbtw_5r4thPMtGWNdaSMoaOiD81h_8-BUgI05ctycU0QBlWoNx-nNdEHuX2lx8viHJ2BQ9lEZwlzUkV1gONtdeciFfSom1HGC8DfLDPBKafBl8KsruQktElJOT73pI9vNeJSZfuI9Fhbge-WBB8u5U-QUeMDyW4QvMbt)], i=5 (sum=3)|2|

循环结束，最终返回 result = 2。

#### 优势

- **高效性**：每个元素最多被左右指针各访问一次，因此时间复杂度为 **O(n)**，大大优于暴力解法的 O(n²)。
    
- **空间复杂度**：只使用了有限的几个变量，所以空间复杂度为 **O(1)**。
