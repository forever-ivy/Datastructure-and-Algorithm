
```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```
### 代码解析：二分查找 (Binary Search)

这段 C++ 代码实现的是一个经典的**二分查找**算法。该算法的目的是在一个**已排序**的数组中高效地找到目标值 target 的索引。如果找到，则返回其索引；如果未找到，则返回 -1。

#### 核心思想：分而治之

二分查找的精髓在于**分而治之 (Divide and Conquer)**。[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFb_ANIZEmG1o33WfPaqqfOJQcOO3NAnolt2N1T9bp7_jvnJArx93nkPVzuQFfAywj5smAW3VtfzM5qtadsKKcCZAoM3HwENfPHjhnO2FRsYeNzPv7nA9sfdhcu3Opq5zTV0djgkPyTl1dNfD2l8UoIlV0duBdbHKff3-U3IB4VCPub)] 它通过不断将搜索范围缩小一半来快速定位目标值。[[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHiVCTVQd0kliYbMVH7d7SE1wX0YyyJJ9T01F0t8cg8WA9j_IFWPKet8d_4P5Nub39hmkQsCWdRGloJaYXOC93T7g2PqBcYadlZURb58CsMUebpmH1F4uLwYKzqHJb7iTe2RezXg6_g-gy4Qrsdou0ELcA27FT4sKOfZ19ZMhjiCath_tEs1UbvS9ZgUANuKWVw-AlGMw%3D%3D)] 其基本前提是：==**数组必须是有序的**==。[[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFkP1MpRC9k8Hf1XtkQNZeJiQKpBuc3asFNjvRHulGXy2Eu1egGUiYQo7d0-zGiVl3_0QMh1R0M3KQvDdzpGpQi2wQH0AUVjH9V5009HiFP93ulktT2yKyNI_oasKL9nqoU403KjHGIHzcD4tVUeWxg_IgddC5cL1lXgg%3D%3D)]

算法的基本步骤如下：

1. **确定范围**：从数组的整个范围开始搜索，即 left 指向数组头部（索引 0），right 指向数组尾部（索引 nums.size() - 1）。[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFnKGpE7_6wUTty7-b00An6pFznIFjIw4JKkprDtbXZ_OYi0UXRfc83TzLshU-TNM4B3_8X0x71o-p6bWsGs_K1CGdXnssvjRF2L5ga9ZZgkYCes2-pAAaYCRhe2U7Wgo8FzA%3D%3D)]
    
2. **找到中间点**：计算当前搜索范围的中间位置 middle。[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFnKGpE7_6wUTty7-b00An6pFznIFjIw4JKkprDtbXZ_OYi0UXRfc83TzLshU-TNM4B3_8X0x71o-p6bWsGs_K1CGdXnssvjRF2L5ga9ZZgkYCes2-pAAaYCRhe2U7Wgo8FzA%3D%3D)]
    
3. **比较**：将中间位置的元素 nums[middle] 与 target 进行比较。[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFnKGpE7_6wUTty7-b00An6pFznIFjIw4JKkprDtbXZ_OYi0UXRfc83TzLshU-TNM4B3_8X0x71o-p6bWsGs_K1CGdXnssvjRF2L5ga9ZZgkYCes2-pAAaYCRhe2U7Wgo8FzA%3D%3D)]
    
    - 如果 nums[middle] **大于** target，说明目标值只可能存在于中间点的**左侧**部分。因此，更新 right 指针，将搜索范围缩小为左半部分。[[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQE4to9_8rOiPc0VNqR8nhx_vUgGPalo4KR960uaonVpkKocjTNGtaqBJwEyXLBol0VxiqP1_QJ3m2KDIGABMzkGQL_KNz9mEuBBtxlUaLIjc7jhgrvbOoy7nCyH9NRa5pUE6mW7DpStwZiVNjwEG4u8_zY%3D)]
        
    - 如果 nums[middle] **小于** target，说明目标值只可能存在于中间点的**右侧**部分。因此，更新 left 指针，将搜索范围缩小为右半部分。[[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQE4to9_8rOiPc0VNqR8nhx_vUgGPalo4KR960uaonVpkKocjTNGtaqBJwEyXLBol0VxiqP1_QJ3m2KDIGABMzkGQL_KNz9mEuBBtxlUaLIjc7jhgrvbOoy7nCyH9NRa5pUE6mW7DpStwZiVNjwEG4u8_zY%3D)]
        
    - 如果 nums[middle] **等于** target，说明已经找到了目标值，直接返回 middle 索引。
        
4. **重复**：持续重复第 2 和第 3 步，直到 left 指针越过 right 指针（即 left > right），这表示搜索范围为空，数组中不存在目标值。
    

#### 代码执行流程

1. **初始化**：
    
    - left = 0;：左指针指向数组的第一个元素。
        
    - right = nums.size() - 1;：右指针指向数组的最后一个元素。
        
2. **循环条件**：
    
    - while(left <= right)：只要左指针在右指针的左边或与右指针重合，就意味着搜索区间 [left, right] 仍然有效，循环继续。当 left > right 时，循环终止。
        
3. **计算中间索引**：
    
    - int middle = left + ((right - left) / 2);：这是计算中间索引的标准写法。
        
    - **为什么不直接用 (left + right) / 2**？ 虽然在数学上等价，但在处理非常大的数组时，left + right 的结果可能会超出整型（int）的最大表示范围，导致**整数溢出 (Integer Overflow)**，从而得到错误的 middle 值。[[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGV8FaM15imVkjnn1mF-knZaoeAOKRku3PADaNPJ7BrTWkZSwwuGgkROF3FG_aXyi7vEZ6NhJ_OSiAGUGJMbCInuBfTuLmrrQzv4cj_csi9C1JLhfjPZdfMf2qLedZAEu9Tm97tkzq8ZGJpsRNjvG6d7ver-iQqN6SBhucD4Jzw8nyReJkdoNX8YbJ4yXm9TUWaqhCG-7uLsirxpli1FzmSekB555GTqfFE-4Z1fKzuO5C1E9jPIv6vf2QC2Q%3D%3D)][[7](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGiPngC-BBPMfJC-QXBg8PZT5V8gK8bz_Fl0xLp1IrLUqkyPMJ0d5gSFnPO1eYQdL3f4Bz2Yj0Q7bfIxmNSAdO_L1iUvNu_OXihL7dq-u9gO8XUmjSKWiWo6vr0fsRHuSsP1Ne9irbhkwdlCMABcZ8jEB7r1CaD7V7A8A%3D%3D)] 而 left + ((right - left) / 2) 的写法巧妙地避免了这个问题，因为 right - left 永远不会比 right 本身更大。[[8](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQH8APGccG_zq0rRI2aE3w6a5n18ilCcCve24sICzX3YNyq3fPDrn1rbNFjPSCpavHVIZy7viT7b9YXJJD5ydo_Jfsu5ryNVBiwO0pz4GiREJy5MG4Hz6kmFqWl46K8d18BKmA7C8m-yLouVfmDiW0BCVKQtSUGdXC1G6RiM3-1KOSl_uVFqAOjfsu1luTlS)][[9](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQGVu_juReoerydcafBY4wMn6013L5ppFND0WiGqgecwSeJHSAmk0fuz8DoVd219-_xKfVdssHfaZWzMSXkq1xRW-ysyspxSHkPDwDaNsn3jYJ9Nt3dw6u1KkAydBRzZ2hRj-UsE26MDcCvT9YyU0IrbFkis0aMIqoFRl2i90k5bl_pgMy57rv0c83PSZCdc1RdfvRYApffy96QydxtSwjWEl2zFCb-6aEuOP9NvH0Lot07CnvI%3D)]
        
4. **比较与更新**：
    
    - if(nums[middle] > target)：如果中间值太大，说明目标值在左边，因此将右边界收缩到 middle 的前一个位置 right = middle - 1;。
        
    - else if(nums[middle] < target)：如果中间值太小，说明目标值在右边，因此将左边界扩展到 middle 的后一个位置 left = middle + 1;。
        
    - else：如果不大也不小，那就是相等，找到了目标值，直接 return middle;。
        
5. **返回结果**：
    
    - 如果循环结束了还没找到（即 while 循环因为 left > right 而终止），说明数组中不存在 target，函数返回 -1。
        

#### 举例说明

假设 nums = [2, 5, 7, 8, 11, 12] 并且 target = 11。

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|迭代次数|left|right|middle 计算|nums[middle]|结果|
|1|0|5|0 + (5-0)/2 = 2|nums[[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFkP1MpRC9k8Hf1XtkQNZeJiQKpBuc3asFNjvRHulGXy2Eu1egGUiYQo7d0-zGiVl3_0QMh1R0M3KQvDdzpGpQi2wQH0AUVjH9V5009HiFP93ulktT2yKyNI_oasKL9nqoU403KjHGIHzcD4tVUeWxg_IgddC5cL1lXgg%3D%3D)] = 7|7 < 11, left = middle + 1 = 3|
|2|3|5|3 + (5-3)/2 = 4|nums[[10](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFrboJbSdv_1OhDlvGwBBrwCWVZ0UnB6i0VGM1BLWxKEFYocU1hoBAOFgsHbaiNKEmG-ZiJsDZwkBm3loCWFiYB7oYNPkvWzlrngQ-qdiIHx-k6T_6fTB1dvNkRFu0lJarIiMaGMDk%3D)] = 11|11 == 11, 找到！返回 4|

函数最终返回 4。

#### 优势与应用

- **高效性**：二分查找最大的优势是其极高的效率。由于每次都将搜索范围减半，其时间复杂度为 **O(log n)**。[[11](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEbN57u2fE3Fw0-ywKE55VLUb4cNPltZHJsDSr5q11FI3krCFLO23VuStgvhzqnJB_XEKmxvzCxs0ZumPCcdcaI0XPhWbN_GdwqqwVnTrzN342ioe9TSKGYAq8OiC4fqtrL5Ip1_aLJUN4STeC3lxpIdPLk)] 这意味着即使在拥有数百万个元素的海量数据中，也能非常迅速地完成查找。
    
- **局限性**：它最大的前提是数据必须**预先排序**。对于无序数据，需要先进行排序或使用其他查找方法。
    

