```
class Solution {
public:
    vector<int> sortedSquares(vector<int>& A) {
        int k = A.size() - 1;
        vector<int> result(A.size(), 0);
        for (int i = 0, j = A.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素
            if (A[i] * A[i] < A[j] * A[j])  {
                result[k--] = A[j] * A[j];
                j--;
            }
            else {
                result[k--] = A[i] * A[i];
                i++;
            }
        }
        return result;
    }
};
```


### 代码解析：双指针法

这段 C++ 代码非常巧妙地解决了一个问题：为一个**按非递-减顺序排序**的整数数组，返回一个包含每个数字平方的新数组，并且这个新数组也要保持非递-减顺序。[[1](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFdk1n2IOtTxSvKksLsyTw_RxPkG89ZBK6ZxSuViAKPxFmo_xK5HOMatn0c8S4PfPkjbkhijb0nBvB74fIhX10ikMp9HdheUeh85UxiH5jWJMCZ7vqJkXhJkjw6adZIA-LA_Mp4l-2Pr76pb1Jd8Vstx6o%3D)]

常规思路可能是先将数组中的每个元素平方，然后对结果数组进行排序。这种方法的时间复杂度会因为排序步骤而达到 O(n log n)。[[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHjuzUFvtdf5bwVRXCvkdscZPuT7s7hFH4pW2c6T8zimzGp_g6UblQ7AKsnGlc7Z_t_gInGDvSL-pRDq_Ew10W5EJBcGuE8o5llM0kWGmCS1_UinSa0lNO3LSNR3-lQ_iRQGa-GaLMjrkmG7IclwX8t)] 然而，这段代码利用**双指针法**，设计了一个时间复杂度为 O(n) 的更优解法。[[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHP06mRwKR-ItRVRWshQyI4W46RsJEe-8Mtbead1f9gV2LO4R5QUCaG1-3v35pMJDmHCdgW4rB94M8UCg-pslpwKFX9ObaMDAV4HbeSun0ojOOj7SLP6JY78Z2z-HuRQpsi3vfv1FfPAuissKObQ86cNw41hR_SF5BjsnII0ideu7D5E2AxqqQGoMGZr081KWZOTfS8gUnN7_VNtSqHrfAOkhZ6VQ%3D%3D)]

#### 核心思想：从两端到中间

由于原始数组 A 是有序的，其元素的平方值最大的数，必然出现在数组的**最左端**或**最右端**（因为负数的平方可能很大）。[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFhISl8H_fuOU0754pYPDcCcUNHseJfdsn363yuIEuTu2gDkOSqzqJwhbqei1K9EmkKpWgZzpI_2F6Zfzsubs_TKq3OXfYEd7Nflk_kj1eKprJfHZZrRElOtqX6j9kGA2TJi8-fPktP1OUxKPsHBlscgJ8mCeWW36rsp23_TZsKwwFcH-c%3D)] 例如，在 [-5, -1, 0, 2, 4] 中，最大的平方值来自 -5 (25) 和 4 (16)，也就是两端的数。

该算法正是利用了这一特性：

1. 设置两个指针，i 指向数组的开头，j 指向数组的末尾。[[5](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHQxfftJPx9qu_GEiWcuu26lKvyF32ke8MxujPNxuIcwXqCkUV6QtAEvmJoSOJLYlbHv_zQXMaCRoH3gKgAJrt8RYe4nrLw_ALXl0mglYrw0QwnYniSOkhqtdlIip-mz3wInCXdrnsrtTtC0VsFnamhvQgnetkxc73Na6te3Jwk)]
    
2. 同时，创建一个与原数组等大的结果数组 result，并用一个指针 k 指向 result 数组的末尾。
    
3. 比较 A[i] 的平方和 A[j] 的平方，将**较大**的那个值放入 result 数组的 k 位置。
    
4. 根据哪一端的元素被选中，移动相应的指针（i++ 或 j--）并向前移动 k 指针（k--）。
    
5. 重复这个过程，直到 i 和 j 指针相遇或交错。
    

通过这种方式，每次都将当前可选范围内的最大平方值从后往前填入新数组，从而自然地构建出一个有序的结果。

#### 代码执行流程

1. **初始化**：
    
    - vector<int> result(A.size(), 0);：创建一个和 A 等大的 result 数组，并初始化所有值为 0。
        
    - int i = 0;：左指针，指向 A 的起始位置。
        
    - int j = A.size() - 1;：右指针，指向 A 的结束位置。
        
    - int k = A.size() - 1;：结果指针，指向 result 的结束位置。
        
2. **循环条件**：
    
    - for (...; i <= j;)：循环会一直进行，直到左指针 i 越过右指针 j。 i <= j 的条件确保了当 i 和 j 相遇时（数组元素为奇数个），中间那个元素也会被处理。
        
3. **比较与赋值**：
    
    - if (A[i] * A[i] < A[j] * A[j])：比较两端元素的平方值。
        
    - 如果右指针 j 指向的数的平方更大，就将 A[j] * A[j] 存入 result[k]。然后将 j 向左移动一位 (j--)。
        
    - else：如果左指针 i 指向的数的平方更大或等于右指针的，就将 A[i] * A[i] 存入 result[k]。然后将 i 向右移动一位 (i++)。
        
    - result[k--] = ...;：无论哪种情况，赋值后 k 都会向前移动一位，为下一个最大值准备位置。
        
4. **返回结果**：
    
    - 当循环结束时，result 数组就已经被从大到小地完全填满了，函数直接返回 result。
        

#### 举例说明

假设 A = [-4, -1, 0, 3, 10]。

|   |   |   |   |   |   |   |   |
|---|---|---|---|---|---|---|---|
|i|j|k|A[i]^2|A[j]^2|比较|操作|result 数组状态|
|0|4|4|16|100|16 < 100|result[[4](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQFhISl8H_fuOU0754pYPDcCcUNHseJfdsn363yuIEuTu2gDkOSqzqJwhbqei1K9EmkKpWgZzpI_2F6Zfzsubs_TKq3OXfYEd7Nflk_kj1eKprJfHZZrRElOtqX6j9kGA2TJi8-fPktP1OUxKPsHBlscgJ8mCeWW36rsp23_TZsKwwFcH-c%3D)] = 100; j--; k--;|[0, 0, 0, 0, 100]|
|0|3|3|16|9|16 > 9|result[[3](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHP06mRwKR-ItRVRWshQyI4W46RsJEe-8Mtbead1f9gV2LO4R5QUCaG1-3v35pMJDmHCdgW4rB94M8UCg-pslpwKFX9ObaMDAV4HbeSun0ojOOj7SLP6JY78Z2z-HuRQpsi3vfv1FfPAuissKObQ86cNw41hR_SF5BjsnII0ideu7D5E2AxqqQGoMGZr081KWZOTfS8gUnN7_VNtSqHrfAOkhZ6VQ%3D%3D)] = 16; i++; k--;|[0, 0, 0, 16, 100]|
|1|3|2|1|9|1 < 9|result[[2](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQHjuzUFvtdf5bwVRXCvkdscZPuT7s7hFH4pW2c6T8zimzGp_g6UblQ7AKsnGlc7Z_t_gInGDvSL-pRDq_Ew10W5EJBcGuE8o5llM0kWGmCS1_UinSa0lNO3LSNR3-lQ_iRQGa-GaLMjrkmG7IclwX8t)] = 9; j--; k--;|[0, 0, 9, 16, 100]|
|1|2|1|1|0|1 > 0|result[[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEU7jcM3bqroVyHiY1oXaO4YP8Cp57qXlNjYUh8EKOIAhfY0CfZEx6NsHwBZ9QwmNRypUeie8WM3Ga1xSUGENHqGajFqSYA2vLXTR6YX7yLHudHGgoJr2D5gCry4liRans%3D)] = 1; i++; k--;|[0, 1, 9, 16, 100]|
|2|2|0|0|0|0 == 0|result = 0; i++; k--;|[0, 1, 9, 16, 100]|

循环结束 (此时 i=3, j=2, i > j)，返回 result。

#### 优势

- **高效性**：该算法只遍历数组一次，因此时间复杂度为 **O(n)**，远优于先平方再排序的 O(n log n) 方法。[[6](https://www.google.com/url?sa=E&q=https%3A%2F%2Fvertexaisearch.cloud.google.com%2Fgrounding-api-redirect%2FAUZIYQEU7jcM3bqroVyHiY1oXaO4YP8Cp57qXlNjYUh8EKOIAhfY0CfZEx6NsHwBZ9QwmNRypUeie8WM3Ga1xSUGENHqGajFqSYA2vLXTR6YX7yLHudHGgoJr2D5gCry4liRans%3D)]
    
- **空间复杂度**：需要一个额外的数组来存储结果，因此空间复杂度为 **O(n)**。
    

