```
#include <iostream>
#include <vector>
using namespace std;
int main() {
    int n, a, b;
    cin >> n;
    vector<int> vec(n);
    vector<int> p(n);
    int presum = 0;
    for (int i = 0; i < n; i++) {
        cin >> vec[i];
        presum += vec[i];
        p[i] = presum;
    }

    while (cin >> a >> b) {
        int sum;
        if (a == 0) sum = p[b];
        else sum = p[b] - p[a - 1];
        cout << sum << endl;
    }
}
```
### 代码解析：前缀和 (Prefix Sum)

这段 C++ 代码解决的是一个非常经典的**区间和查询**问题：给定一个固定数组，需要快速、多次地计算任意指定区间的元素之和。(==连续的数组== )

直接的方法是每次查询都遍历一遍区间 [a, b] 并累加求和，但如果查询次数非常多，这种方法会非常慢，因为存在大量重复计算。该代码采用了一种名为**前缀和**的技巧，通过预处理来极大地优化查询效率。

#### 核心思想：前缀和

前缀和的核心思想是**空间换时间**。它通过创建一个额外的辅助数组（在此代码中是 p），来预先存储从数组开头到每个位置的累计和。

- **定义**：前缀和数组 p 中，p[i] 的值等于原数组 vec 从第 0 个元素到第 i 个元素的总和。即 p[i] = vec[0] + vec[1] + ... + vec[i]。
    
- **如何利用**：一旦我们有了这个前缀和数组 p，计算任意区间 [a, b] 的和就变得极其简单和快速。
    
    - p[b] 存储了从 vec[0] 到 vec[b] 的和。
        
    - p[a-1] 存储了从 vec[0] 到 vec[a-1] 的和。
        
    - 那么，p[b] - p[a-1] 的结果，正好就是从 vec[a] 到 vec[b] 这一段区间的和。
        
    
    **公式**: sum(a, b) = p[b] - p[a-1]
    

通过一个简单的减法操作，就能替代原来需要遍历求和的循环，从而将每次查询的时间复杂度从 O(n) 降至 O(1)。

#### 代码执行流程

1. **输入与初始化**：
    
    - cin >> n;：读取原数组 vec 的长度 n。
        
    - vector<int> vec(n);：定义原数组。
        
    - vector<int> p(n);：定义前缀和数组。
        
    - int presum = 0;：用于计算前缀和的临时变量。
        
2. **构建前缀和数组（预处理阶段）**：
    
    - for (int i = 0; i < n; i++) { ... }：这个循环只执行一次，用于构建前缀和数组 p。
        
    - cin >> vec[i];：读取原数组的每一个元素。
        
    - presum += vec[i];：将当前元素累加到 presum 中。
        
    - p[i] = presum;：将当前的累计和存入前缀和数组 p 的对应位置。
        
3. **处理查询（查询阶段）**：
    
    - while (cin >> a >> b)：这是一个循环，会不断地从输入中读取区间的起始下标 a 和结束下标 b，直到没有新的输入为止。这使得代码能够处理任意多次的查询。
        
    - **计算区间和**：
        
        - if (a == 0)：这是一个特殊情况。如果查询的区间从索引 0 开始，那么其总和就是 p[b] 本身（即从 vec[0] 到 vec[b] 的和），无需做减法。
            
        - else sum = p[b] - p[a - 1];：对于一般情况 a > 0，应用前缀和公式计算区间 [a, b] 的和。
            
    - cout << sum << endl;：输出计算出的区间和。
        

#### 举例说明

根据题目提供的示例：

- n = 5
    
- vec = [1, 2, 3, 4, 5]
    

1. **构建前缀和数组 p**:
    
    - i=0: presum=1, p[0]=1
        
    - i=1: presum=1+2=3, p[1]=3
        
    - i=2: presum=3+3=6, p[2]=6
        
    - i=3: presum=6+4=10, p[3]=10
        
    - i=4: presum=10+5=15, p[4]=15
        
    - 最终 p = [1, 3, 6, 10, 15]
        
2. **处理查询**:
    
    - **查询 0 1**:
        
        - a = 0, b = 1。
            
        - 因为 a == 0，所以 sum = p[b] = p[1] = 3。
            
        - 输出 3。 (验证: vec[0] + vec[1] = 1 + 2 = 3)
            
    - **查询 1 3**:
        
        - a = 1, b = 3。
            
        - sum = p[b] - p[a-1] = p[3] - p[0] = 10 - 1 = 9。
            
        - 输出 9。 (验证: vec[1] + vec[2] + vec[3] = 2 + 3 + 4 = 9)
            

#### 优势与应用

- **高效性**：预处理阶段的时间复杂度是 O(n)。之后的每次查询都只需要 O(1) 的时间。这对于需要进行大量区间和查询的场景来说，总效率极高。
    
- **应用场景**：前缀和是许多更复杂算法（如差分数组、二维前缀和）的基础，广泛应用于计算几何、数据处理和算法竞赛中。