
### 1. 题目解读与核心要求

**题目**: 给定两个字符串 `s` 和 `t`，判断 `t` 是否是 `s` 的字母异位词。

**什么是“字母异位词” (Anagram)？**

这是解题的关键。字母异位词的定义包含两个核心条件：

1.  两个字符串包含的**字符种类**必须完全相同。
2.  每一种字符出现的**数量**也必须完全相同。

简单来说，就是两个字符串互为对方的“乱序重排”版本。

**示例分析**:

*   `s = "anagram"`, `t = "nagaram"`
    *   字符 'a' 都在 3 次。
    *   字符 'n' 都在 1 次。
    *   字符 'g' 都在 1 次。
    *   ...等等。
    *   所有字符和数量都匹配，所以它们是字母异位词。

*   `s = "rat"`, `t = "car"`
    *   `s` 包含 't'，但 `t` 不包含。
    *   `t` 包含 'c'，但 `s` 不包含。
    *   字符种类不同，所以它们不是字母异位词。

**约束条件**: "你可以假设字符串只包含小写字母。"
这是一个非常重要的提示！它告诉我们，需要处理的字符集非常小，只有 'a' 到 'z' 这 26 个字符。这个信息是高效解法的突破口。

---

### 2. 解题思路的演进

#### 思路一：排序法 (Brute Force)

最直观的想法是：如果两个字符串是字母异位词，那么将它们各自的字符排序后，得到的结果应该是一模一样的。

*   **步骤**:
    1.  对字符串 `s` 进行排序。
    2.  对字符串 `t` 进行排序。
    3.  比较排序后的两个字符串是否相等。
*   **代码 (伪代码)**: `sort(s) == sort(t)`
*   **优点**: 思路简单，容易实现。
*   **缺点**: 时间复杂度较高。排序的时间复杂度通常是 O(n log n)，其中 n 是字符串的长度。

#### 思路二：哈希法 (最优解)

既然我们只关心字符的种类和数量，而不关心顺序，那么我们可以用一个“账本”来记录每个字符出现的次数。这就是**哈希法**的核心思想。

*   **步骤**:
    1.  **准备一个账本**：用来记录 `s` 中每个字符出现的次数。
    2.  **记账**：遍历 `s`，每出现一个字符，就在账本上对应地记一笔。
    3.  **销账**：遍历 `t`，每出现一个字符，就在账本上对应地销一笔。
    4.  **查账**：最后检查账本。如果账本上所有条目都正好清零，说明 `s` 和 `t` 的字符构成完全一样。

*   **如何实现“账本”？**
    *   **通用方法**: 使用哈希表，比如 C++ 的 `std::unordered_map<char, int>`。键是字符，值是出现的次数。
    *   **本题的优化**: 题目给了关键线索——“只包含小写字母”。这意味着我们的“账本”只需要记录 26 个条目。对于这种**键的集合是有限且固定的**情况，我们完全可以用一个**简单的数组**来模拟哈希表，其性能比真正的哈希表还要高！

---

### 3. 代码解析 (您提供的最优解)

这个解法正是**“哈希法-数组实现”**的完美体现。

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        // 步骤 0: 长度不同，必不是异位词 (一个可选的提前剪枝优化)
        if (s.length() != t.length()) {
            return false;
        }

        // 步骤 1: 准备一个大小为26的数组作为“账本”，并全部初始化为0
        int record[26] = {0};

        // 步骤 2: 遍历 s，进行“记账” (增加计数)
        for (int i = 0; i < s.size(); i++) {
            // 通过 s[i] - 'a' 将字符 'a'->0, 'b'->1, ... 映射到数组索引
            record[s[i] - 'a']++;
        }

        // 步骤 3: 遍历 t，进行“销账” (减少计数)
        for (int i = 0; i < t.size(); i++) {
            record[t[i] - 'a']--;
        }

        // 步骤 4: 查账。遍历账本，看是否所有账目都清零了
        for (int i = 0; i < 26; i++) {
            if (record[i] != 0) {
                // 只要有一个不为0，说明字符数量不匹配
                return false;
            }
        }
        
        // 如果循环结束，所有账目都为0，说明是异位词
        return true;
    }
};
```

**代码亮点分析**:

*   **`record[s[i] - 'a']`**: 这是整个算法最精髓的地方。它利用了字符在内存中是以 ASCII 码（或兼容编码）连续存储的特性，通过一个简单的减法，实现了从**字符到数组索引**的完美 O(1) 映射，这就是哈希思想的体现。
*   **空间换时间**: 该算法使用了一个大小为 26 的额外数组（空间），将时间复杂度从 O(n log n) 成功地降低到了 **O(n)**。
*   **常数空间**: 因为数组大小是固定的 26，不随输入字符串的长度 `n` 变化，所以空间复杂度被认为是 **O(1)**。

