```
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        // 找出a + b + c = 0
        // a = nums[i], b = nums[left], c = nums[right]
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) {
                return result;
            }
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }
            int left = i + 1;
            int right = nums.size() - 1;
            while (right > left) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (right > left && nums[right] == nums[right - 1]) right--;
                while (right > left && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (right > left && nums[right] == nums[right - 1]) right--;
                    while (right > left && nums[left] == nums[left + 1]) left++;

                    // 找到答案时，双指针同时收缩
                    right--;
                    left++;
                }
            }

        }
        return result;
    }
};
```

### 算法核心思想

算法的整体思路是 **“固定一个数，然后在其后的区间内寻找另外两个数”**，并通过双指针法将寻找另外两个数的时间复杂度从 O(N²) 降到了 O(N)。

1.  **排序**：首先对数组进行排序，这是使用双指针法的前提。
2.  **遍历固定 `a`**：通过一层 `for` 循环，从左到右遍历数组，每次循环固定一个数作为三元组中的第一个元素 `a`。
3.  **双指针查找 `b` 和 `c`**：在 `a` 后面的数组区间内，设置 `left` 和 `right` 两个指针，分别指向区间的开始和结束。通过移动这两个指针，来寻找满足 `a + b + c = 0` 的 `b` 和 `c`。
4.  **去重**：在整个过程中，巧妙地处理重复元素，确保最终结果集中没有重复的三元组。

---

### 代码逐行解析

```cpp
vector<vector<int>> result;
sort(nums.begin(), nums.end());
```
*   `sort()`: 对数组进行升序排序。这是所有后续操作的基础。

```cpp
for (int i = 0; i < nums.size(); i++) {
```
*   开始主循环，`i` 用于固定第一个元素 `a`，即 `nums[i]`。

```cpp
    if (nums[i] > 0) {
        return result;
    }
```
*   **剪枝优化**：由于数组已排序，如果 `a` (`nums[i]`) 已经大于 0，那么后面的 `b` (`nums[left]`) 和 `c` (`nums[right]`) 必然也是非负数。三个非负数（其中一个还大于0）相加不可能等于 0。所以可以直接结束循环，返回已有的结果。

```cpp
    // 正确去重a方法
    if (i > 0 && nums[i] == nums[i - 1]) {
        continue;
    }
```
*   **对 `a` 进行去重**：这是去重的第一步，也是非常关键的一步。
    *   `i > 0`: 确保 `i-1` 不会越界。
    *   `nums[i] == nums[i - 1]`: 判断当前固定的 `a` 是否和上一个固定的 `a` 相同。
    *   **为什么这样做？** 假设数组是 `[-1, -1, 0, 1, 2]`。
        *   当 `i=0` 时，`a = -1`，程序会找到三元组 `[-1, 0, 1]`。
        *   当 `i=1` 时，`a` 还是 `-1`。如果**不**进行去重，程序会**再次**找到 `[-1, 0, 1]`，导致结果重复。
        *   通过 `continue` 跳过，可以保证对于重复的 `a`，我们只用第一个 `a` 去查找组合，后续重复的 `a` 都会被忽略。

```cpp
    int left = i + 1;
    int right = nums.size() - 1;
    while (right > left) {
```
*   **初始化双指针**：
    *   `left` 指针指向 `a` 右边的第一个元素。
    *   `right` 指针指向数组的最后一个元素。
    *   `while (right > left)`: 只要两个指针没有相遇，就继续在 `[left, right]` 这个区间内查找。

```cpp
        if (nums[i] + nums[left] + nums[right] > 0) right--;
        else if (nums[i] + nums[left] + nums[right] < 0) left++;
```
*   **移动指针**：这是双指针法的精髓。
    *   `sum > 0`: 如果三数之和大于 0，说明总和太大了。由于数组是有序的，我们需要减小总和，所以将 `right` 指针左移 (`right--`)，换一个更小的数 `c`。
    *   `sum < 0`: 如果三数之和小于 0，说明总和太小了。需要增大总和，所以将 `left` 指针右移 (`left++`)，换一个更大的数 `b`。

```cpp
        else { // sum == 0
            result.push_back(vector<int>{nums[i], nums[left], nums[right]});
```
*   **找到一个解**：当三数之和等于 0 时，我们就找到了一个符合条件的三元组，将其存入 `result`。

```cpp
            // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
            while (right > left && nums[right] == nums[right - 1]) right--;
            while (right > left && nums[left] == nums[left + 1]) left++;
```
*   **对 `b` 和 `c` 进行去重**：这是去重的第二步，也是最巧妙的地方。
    *   在找到一个解 `[a, b, c]` 之后，`left` 和 `right` 指针不能只移动一次。
    *   假设数组是 `[-2, 0, 0, 2, 2]`，当 `a=-2` 时，`left` 指向 `0`，`right` 指向 `2`。我们找到了 `[-2, 0, 2]`。
    *   **如果不去重**，下一次 `left++`，`right--`，指针依然分别指向 `0` 和 `2`，会再次找到 `[-2, 0, 2]`。
    *   `while (nums[right] == nums[right - 1]) right--;`: 这行代码会持续移动 `right` 指针，跳过所有与当前 `c` (`nums[right]`) 重复的元素。
    *   `while (nums[left] == nums[left + 1]) left++;`: 同理，跳过所有与当前 `b` (`nums[left]`) 重复的元素。

```cpp
            // 找到答案时，双指针同时收缩
            right--;
            left++;
        }
    }
}
```
*   在对 `b` 和 `c` 去重之后（即指针已经跳到了下一个不重复的位置），我们需要继续寻找**新的、不同的 `b` 和 `c`** 的组合。所以将 `left` 和 `right` 指针同时向中间收缩，开始下一轮的查找。

```cpp
return result;
```
*   `for` 循环结束后，返回最终的结果集。

### 总结

这段代码堪称完美，它好在：
1.  **算法最优**：时间复杂度为 O(N²)，其中 O(N log N) 用于排序，O(N²) 用于遍历和双指针查找。空间复杂度为 O(1) (不考虑存储结果的 `result` 数组)。
2.  **逻辑清晰**：固定 `a` -> 双指针找 `b`, `c` 的思路非常清晰。
3.  **去重严谨**：分别在三个关键位置对 `a`, `b`, `c` 进行了彻底且正确的去重，注释中还点出了错误去重方式的问题所在，这在面试中是非常大的加分项。