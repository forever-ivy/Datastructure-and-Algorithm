
```
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        std::unordered_map <int,int> map;
        for(int i = 0; i < nums.size(); i++) {
            // 遍历当前元素，并在map中寻找是否有匹配的key
            auto iter = map.find(target - nums[i]); 
            if(iter != map.end()) {
                return {iter->second, i};
            }
            // 如果没找到匹配对，就把访问过的元素和下标加入到map中
            map.insert(pair<int, int>(nums[i], i)); 
        }
        return {};
    }
};
```


### 1. 题目解读与核心要求

**题目**: 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出**和为目标值**的那**两个**整数，并返回它们的数组**下标**。

**关键点**:
1.  **找两个数**: 不是一个，也不是多个。
2.  **和为 `target`**: `nums[i] + nums[j] == target`。
3.  **返回下标**: 返回的是 `i` 和 `j`，而不是 `nums[i]` 和 `nums[j]`。
4.  **唯一解**: 题目通常会假设每种输入只会对应一个答案。

**示例分析**:
`nums = [2, 7, 11, 15]`, `target = 9`
*   我们发现 `2 + 7 = 9`。
*   `2` 的下标是 `0`，`7` 的下标是 `1`。
*   所以返回 `[0, 1]`。

---

### 2. 解题思路的演进

#### 思路一：暴力解法 (Brute Force)

最直观的方法就是穷举所有可能的组合：
*   用一个 `for` 循环固定第一个数 `nums[i]`。
*   再用一个嵌套的 `for` 循环在 `i` 之后寻找第二个数 `nums[j]`。
*   判断 `nums[i] + nums[j]` 是否等于 `target`。
*   时间复杂度: **O(n²)**。对于大数据量的 `nums` 数组，这个方法会超时。

#### 思路二：哈希法 (最优解)

暴力解法的瓶颈在于**“寻找”**另一个数的过程太慢了（需要 O(n) 的时间）。我们如何能把“寻找”这个操作的速度提升到 **O(1)** 呢？

**哈希表 (`unordered_map`)** 就是为此而生的。

**核心思想转换：**
原来的问题是：“对于 `nums[i]`，是否存在一个 `nums[j]` 使得 `nums[i] + nums[j] == target`？”

我们可以把它转换成：“对于 `nums[i]`，**是否存在一个数 `target - nums[i]`**？”

这个问题就变成了一个**快速查找**问题。

**算法流程**:
我们可以遍历数组，对于每一个元素 `nums[i]`，我们都去哈希表中查找我们需要的“另一半”——`target - nums[i]`。

这里有一个非常巧妙的优化：我们**不需要**先把所有元素都放进哈希表。我们可以**一边遍历，一边构建哈希表**。

1.  创建一个空的哈希表 `map`，用来存储**已经遍历过的数字及其下标**，即 `(数字, 下标)`。
2.  开始遍历数组 `nums`，对于当前的元素 `nums[i]`：
    a.  计算出我们需要的“另一半”：`complement = target - nums[i]`。
    b.  **在 `map` 中查找 `complement`**。
        *   如果**找到了**，说明 `complement` 这个数在 `i` 之前**已经出现过**。我们立刻就找到了答案！返回 `complement` 的下标（从 `map` 中获取）和当前元素的下标 `i`。
        *   如果**没找到**，说明到目前为止，`complement` 还没出现过。
    c.  **将当前元素存入 `map`**：将 `(nums[i], i)` 这个键值对存入哈希表中，供**后续**的元素进行查找。
3.  如果遍历完整个数组都没找到，根据题目假设（有唯一解），返回一个空的结果。

---

### 3. 代码逐行解析

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        // 1. 创建哈希表，Key 存数值，Value 存下标
        std::unordered_map <int,int> map;

        // 2. 遍历数组
        for(int i = 0; i < nums.size(); i++) {
            
            // a. 计算需要的“另一半” (target - nums[i])，并在 map 中寻找
            // map.find() 返回一个迭代器
            auto iter = map.find(target - nums[i]); 
            
            // b. 检查是否找到了
            if(iter != map.end()) {
                // 如果 iter 不是 map.end()，说明在 map 中找到了
                // iter->second 就是找到的那个数（“另一半”）的下标
                return {iter->second, i};
            }

            // c. 如果没找到匹配对，就把当前访问过的元素和下标加入到 map 中
            // 供后续的元素查询
            map.insert(pair<int, int>(nums[i], i)); 
        }

        // 3. 如果循环结束还没找到（根据题目假设，通常不会执行到这里）
        return {};
    }
};
```

**代码亮点分析**:

*   **一次遍历 (One-pass)**: 这个算法非常高效，只需要对数组进行一次遍历。
*   **边遍历边插入**: 这是最巧妙的地方。通过将当前元素插入哈希表，它就变成了后续元素的“可查找的历史记录”。这保证了我们找到的两个数一定是不同的元素，并且避免了需要两次遍历（一次建表，一次查找）的麻烦。
*   **`map.find()`**: 提供了 O(1) 的平均查找时间，是整个算法高性能的关键。
*   **`iter->second`**: 当 `find` 成功时，返回的迭代器 `iter` 指向一个 `std::pair`。`iter->first` 是键 (数值)，`iter->second` 是值 (下标)。

### 总结

这个解法堪称哈希表应用的典范。它将一个 O(n²) 的查找问题，通过“空间换时间”的策略（使用了一个哈希表作为额外空间），成功地将时间复杂度降低到了 **O(n)**，是解决此类问题的最优方法。