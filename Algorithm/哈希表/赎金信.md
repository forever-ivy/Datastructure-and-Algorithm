```
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int record[26] = {0};
        //add
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
        for (int i = 0; i < magazine.length(); i++) {
            // 通过record数据记录 magazine里各个字符出现次数
            record[magazine[i]-'a'] ++;
        }
        for (int j = 0; j < ransomNote.length(); j++) {
            // 遍历ransomNote，在record里对应的字符个数做--操作
            record[ransomNote[j]-'a']--;
            // 如果小于零说明ransomNote里出现的字符，magazine没有
            if(record[ransomNote[j]-'a'] < 0) {
                return false;
            }
        }
        return true;
    }
};
```



**问题**：给定两个字符串 `ransomNote` (赎金信) 和 `magazine` (杂志)，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。`magazine` 里的每个字符只能在 `ransomNote` 中使用一次。

**核心思路**：要判断 `ransomNote` 能否由 `magazine` 构成，本质上就是判断**对于每一个小写字母，`ransomNote` 中该字母出现的次数是否不多于 `magazine` 中该字母出现的次数**。

这段代码就完美地实现了这个思路，它使用了一种非常高效的方法——**哈希表（具体实现为数组）**。

---

### 代码逐行解析

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
```
*   这是一个标准的 C++ 类定义，`canConstruct` 是解决问题的主函数，接收两个字符串作为输入，返回一个布尔值 (`true` 或 `false`)。

```cpp
        int record[26] = {0};
```
*   **这是整个算法的核心**。
*   `int record[26]`：创建了一个大小为 26 的整型数组。
*   **为什么是 26？** 因为题目通常会限定字符串只包含小写英文字母（a-z），总共 26 个。这个数组就充当了一个**哈希表**或者说**频率计数器**。
*   数组的**索引 `0` 到 `25`** 将分别对应字母 `'a'` 到 `'z'`。
*   `= {0}`：将数组的所有元素初始化为 0。现在 `record[0]` 表示字母 `'a'` 的计数，`record[1]` 表示 `'b'` 的计数，以此类推，初始值都为 0。

```cpp
        //add
        if (ransomNote.size() > magazine.size()) {
            return false;
        }
```
*   这是一个非常重要的**剪枝优化**。
*   如果 `ransomNote` 的长度比 `magazine` 还要长，那么 `magazine` 里的字符数量无论如何也不可能凑齐 `ransomNote`，所以直接返回 `false`，无需进行后续的计算。这可以提前结束很多无效的用例。

```cpp
        for (int i = 0; i < magazine.length(); i++) {
            // 通过record数据记录 magazine里各个字符出现次数
            record[magazine[i]-'a'] ++;
        }
```
*   **第一步：统计 `magazine` 中每个字符的出现频率。**
*   `for (int i = 0; i < magazine.length(); i++)`: 遍历 `magazine` 字符串中的每一个字符。
*   `magazine[i]`：获取当前遍历到的字符，比如是 `'c'`。
*   `magazine[i]-'a'`：**这是一个巧妙的技巧，用于将字符映射到数组索引。**
    *   在 C++ 中，字符可以被当作整数进行运算（基于它们的 ASCII 值）。
    *   `'c' - 'a'` 的结果是 `2`。
    *   `'a' - 'a'` 的结果是 `0`。
    *   `'z' - 'a'` 的结果是 `25`。
    *   这样，我们就把每个小写字母都唯一地映射到了 `record` 数组的 `0-25` 索引上。
*   `record[...] ++`：将对应字符的计数加一。例如，当遍历到 `'c'` 时，`record[2]` 的值就会增加 1。
*   这个循环结束后，`record` 数组就完整地记录了 `magazine` 中所有字符的出现次数。

```cpp
        for (int j = 0; j < ransomNote.length(); j++) {
            // 遍历ransomNote，在record里对应的字符个数做--操作
            record[ransomNote[j]-'a']--;
```
*   **第二步：消耗 `magazine` 中的字符来构建 `ransomNote`。**
*   `for (int j = 0; j < ransomNote.length(); j++)`: 遍历 `ransomNote` 字符串中的每一个字符。
*   `record[ransomNote[j]-'a']--`: 找到 `ransomNote` 当前字符在 `record` 数组中对应的计数，并将其减一。这模拟了“用掉”一个 `magazine` 里的字符。
  
```cpp
            // 如果小于零说明ransomNote里出现的字符，magazine没有
            if(record[ransomNote[j]-'a'] < 0) {
                return false;
            }
        }
```
*   **这是判断的核心逻辑。**
*   在执行 `--` 操作**之后**，我们检查对应字符的计数是否变成了负数。
*   **为什么小于 0 就说明失败了？**
    *   假设 `magazine` 是 "aab"，`ransomNote` 是 "aaab"。
    *   遍历完 `magazine` 后，`record[0]` (代表 'a') 的值是 `2`。
    *   遍历 `ransomNote`：
        *   第一个 'a'：`record[0]` 变成 `1`。`1 >= 0`，通过。
        *   第二个 'a'：`record[0]` 变成 `0`。`0 >= 0`，通过。
        *   第三个 'a'：`record[0]` 变成 `-1`。`-1 < 0`，检查失败！
    *   `record[0]` 变成 `-1` 意味着，`ransomNote` 需要第三个 'a'，但是 `magazine` 最多只能提供两个。库存不足了，所以无法构成，直接返回 `false`。

*   如果 `ransomNote` 的整个循环都顺利完成了，并且没有触发任何 `record` 计数小于 0 的情况，这意味着 `magazine` 中提供的所有字符都足以满足 `ransomNote` 的需求。
*   因此，函数返回 `true`，表示可以成功构建。

### 算法总结

*   **数据结构**：使用一个大小为 26 的数组作为哈希表，空间复杂度为 O(1)，因为大小是固定的。
*   **时间复杂度**：O(m + n)，其中 m 是 `magazine` 的长度，n 是 `ransomNote` 的长度。因为代码需要分别完整遍历两个字符串各一次。
*   **优点**：非常高效。相比于使用 `std::map` 或 `std::unordered_map`，直接使用数组作为哈希表，在处理固定小范围字符集（如小写字母）时，速度更快，实现也更简单。