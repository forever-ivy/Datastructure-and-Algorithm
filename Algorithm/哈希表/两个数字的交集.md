```
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
        unordered_set<int> nums_set(nums1.begin(), nums1.end());
        for (int num : nums2) {
            // 发现nums2的元素 在nums_set里又出现过
            if (nums_set.find(num) != nums_set.end()) {
                result_set.insert(num);
            }
        }
        return vector<int>(result_set.begin(), result_set.end());
    }
};
```


### 1. 题目解读与核心要求

**题目**: 给定两个整数数组 `nums1` 和 `nums2`，返回它们的**交集**。

**什么是“交集” (Intersection)？**

*   交集指的是**同时存在**于两个数组中的元素所组成的集合。
*   **关键点**: 结果中的每个元素都必须是**唯一的**，不关心出现的次数。
*   **顺序不重要**: 返回结果的顺序可以是任意的。

**示例分析**:
`nums1 = [1, 2, 2, 1]`, `nums2 = [2, 2]`
*   同时出现在两个数组中的数字是 `2`。
*   结果要求唯一，所以最终交集是 `[2]`。

`nums1 = [4, 9, 5]`, `nums2 = [9, 4, 9, 8, 4]`
*   同时存在的数字是 `4` 和 `9`。
*   最终交集是 `[4, 9]` 或 `[9, 4]`（顺序无所谓）。

---

### 2. 解题思路：为什么用哈希集合 (unordered_set)？

如果用最朴素的暴力解法，我们会用两层循环，遍历 `nums1` 中的每个元素，再去 `nums2` 中查找是否存在。这样的时间复杂度是 O(n * m)，在数据量大时效率极低。

这道题的核心需求有两个：
1.  **快速判断**一个元素是否存在于另一个集合中。
2.  对结果进行**去重**。

`std::unordered_set` 这种数据结构简直是为这两个需求量身定做的：
*   **快速查找**: `unordered_set` 基于哈希表，`find()` 操作的平均时间复杂度是 **O(1)**。
*   **自动去重**: `unordered_set` 的特性就是元素唯一，`insert()` 操作会自动处理重复元素。

所以，最优的思路就是利用 `unordered_set` 来优化查找过程和处理结果。

---

### 3. 代码逐行解析

这段代码的逻辑非常清晰，可以分为三个步骤：

**步骤 1: 创建查询“字典”**

```cpp
unordered_set<int> nums_set(nums1.begin(), nums1.end());
```

*   **`unordered_set<int> nums_set(...)`**: 创建一个名为 `nums_set` 的哈希集合，用于存放 `int` 类型的元素。
*   **`(nums1.begin(), nums1.end())`**: 这是 C++ STL 中非常常用的一种**范围构造函数**。它的意思是：“请用 `nums1` 数组从头到尾的所有元素来初始化这个 `nums_set`”。
*   **发生了什么？**
    1.  `nums_set` 会遍历 `nums1` 中的所有元素 (`[1, 2, 2, 1]`)。
    2.  它会尝试将这些元素逐一插入到哈希集合中。
    3.  由于哈希集合的**自动去重**特性，`1` 只会被插入一次，`2` 也只会被插入一次。
*   **执行完这一行**: `nums_set` 就变成了一个内容为 `{1, 2}` 的哈希集合。它就像一本“字典”，我们可以 O(1) 地快速查询任何一个数字是否在 `nums1` 中出现过。

**步骤 2: 遍历 `nums2` 并查找交集**

```cpp
unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重
for (int num : nums2) {
    // 发现nums2的元素 在nums_set里又出现过
    if (nums_set.find(num) != nums_set.end()) {
        result_set.insert(num);
    }
}
```

*   **`unordered_set<int> result_set;`**: 创建另一个哈希集合 `result_set`。它的作用有两个：一是存储最终的结果，二是利用其特性顺便完成对结果的去重。
*   **`for (int num : nums2)`**: 这是一个 C++11 的**范围 for 循环**，它会依次取出 `nums2` () 中的每一个元素赋值给 `num`。
*   **`if (nums_set.find(num) != nums_set.end())`**: 这是整个算法的核心判断。
    *   **`nums_set.find(num)`**: 在我们之前创建的“字典” `nums_set` 中查找当前的 `num`。
    *   **`find()` 的返回值**:
        *   如果**找到了**，它会返回一个指向该元素的迭代器。
        *   如果**没找到**，它会返回一个特殊的迭代器 `nums_set.end()`，它指向集合的“末尾之后”的位置。
    *   所以，`!= nums_set.end()` 这个条件就等价于**“`num` 在 `nums_set` 中被找到了！”**。
*   **`result_set.insert(num);`**: 如果 `num` 确实在 `nums_set` 中（意味着它同时也在 `nums1` 中），我们就把它插入到 `result_set` 里。如果 `result_set` 里已经有了这个 `num`（比如 `nums2` 是 `[2, 2]`，第二次遇到 `2`），`insert` 操作会自动忽略它，从而实现了结果的去重。

**步骤 3: 转换并返回结果**

```cpp
return vector<int>(result_set.begin(), result_set.end());```

*   题目要求返回一个 `vector<int>`。
*   我们再次使用了**范围构造函数**。
*   **`vector<int>(result_set.begin(), result_set.end())`**: 这行代码创建了一个新的 `vector`，并用 `result_set` 从头到尾的所有元素来初始化它。
*   最终，包含不重复交集元素的 `vector` 就被返回了。

### 总结

这个解法非常巧妙地利用了 `unordered_set` 的两大优势：

1.  **O(1) 的快速查找**：将一个数组转换为 `unordered_set`，使得对另一个数组元素的查询效率极大提升。
2.  **O(1) 的自动去重**：无论是对输入数组还是对结果集，`insert` 操作都自然地处理了唯一性的要求。

这使得整个算法的时间复杂度主要由构建哈希集合和遍历数组决定，大约是 **O(n + m)**，远优于 O(n * m) 的暴力解法。