```
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap; //key:a+b的数值，value:a+b数值出现的次数
        // 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中
        for (int a : A) {
            for (int b : B) {
                umap[a + b]++;
            }
        }
        int count = 0; // 统计a+b+c+d = 0 出现的次数
        // 再遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就把map中key对应的value也就是出现次数统计出来。
        for (int c : C) {
            for (int d : D) {
                if (umap.find(0 - (c + d)) != umap.end()) {
                    count += umap[0 - (c + d)];
                }
            }
        }
        return count;
    }
};
```


### 1. 题目解读与核心要求

**题目**: 给定四个包含整数的数组 `A`, `B`, `C`, `D`，计算有多少个元组 `(i, j, k, l)` 能够满足 `A[i] + B[j] + C[k] + D[l] == 0`。

**关键点**:
1.  **四个数组**: 每个数必须从不同的数组中选取。
2.  **求数量**: 我们不是要找出具体的组合，而是要计算出满足条件的组合**有多少种**。
3.  **元素可重复**: 数组中可能有重复的数字，每个都应被独立计算。

**示例分析**:
`A = [1, 2]`, `B = [-2, -1]`, `C = [-1, 2]`, `D = [0, 2]`
满足 `a+b+c+d=0` 的组合有：
*   `A[0]+B[0]+C[0]+D[1] = 1 + (-2) + (-1) + 2 = 0`
*   `A[1]+B[1]+C[0]+D[0] = 2 + (-1) + (-1) + 0 = 0`
*   ... (可能还有其他组合)
最终需要返回这些组合的总数。

---

### 2. 解题思路的演进

#### 思路一：暴力解法 (Brute Force)

最直观的想法就是用四层 `for` 循环，穷举所有 `A, B, C, D` 中元素的组合，然后判断它们的和是否为 0。

*   **时间复杂度**: **O(n⁴)**。如果每个数组的长度是 `n`，那么总的计算次数是 `n*n*n*n`。在 `n` 稍大的情况下（比如 n=500），这会是一个天文数字，绝对会超时。

#### 思路二：哈希法 (最优解) - 分组与转化

暴力解法的瓶颈在于我们需要同时确定四个变量。我们能不能减少变量的数量呢？

**核心思想转换：**

原始的等式是：`a + b + c + d = 0`

我们可以把它变形为：**`a + b = 0 - (c + d)`**

这个变形非常关键，它将问题**一分为二**：

1.  **第一部分**: 计算所有 `a + b` 的可能值。
2.  **第二部分**: 计算所有 `c + d` 的可能值。
3.  **建立联系**: 对于每一个 `c + d` 的和，我们去查找是否存在一个 `a + b` 的和，使得它们相加等于 0。

这个**“查找”**操作，正是哈希表大显身手的舞台！

**算法流程**:
1.  **创建哈希表 `umap`**:
    *   `Key`: `a + b` 的和。
    *   `Value`: 这个和出现的**次数**。
2.  **遍历 `A` 和 `B`**:
    *   用两层 `for` 循环，计算出所有 `a + b` 的和。
    *   将每个和作为 `Key`，其出现次数作为 `Value` 存入 `umap`。如果一个和多次出现，就累加它的出现次数。
3.  **初始化计数器**: `count = 0`。
4.  **遍历 `C` 和 `D`**:
    *   用另外两层 `for` 循环，计算出每一个 `c + d` 的和。
    *   对于每个和 `sum_cd = c + d`，我们计算出它的“目标配对值” `target = 0 - sum_cd`。
    *   **在 `umap` 中查找 `target`**。
        *   如果找到了，说明存在 `a+b` 的和等于 `target`。
        *   那么有多少种组合呢？`umap[target]` 的值告诉我们，`a+b` 等于 `target` 的组合有 `umap[target]` 种。
        *   我们将这个次数累加到 `count` 上：`count += umap[target]`。
5.  **返回结果**: 遍历完 `C` 和 `D` 后，`count` 中就累计了所有满足条件的四元组的总数。

---

### 3. 代码逐行解析

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        // 1. 创建哈希表
        // Key: a+b 的和
        // Value: 这个和出现的次数
        unordered_map<int, int> umap;

        // 2. 遍历 A 和 B，计算所有 a+b 的和及其出现次数
        for (int a : A) {
            for (int b : B) {
                // 如果 umap 中已存在 a+b 这个键，则其值+1
                // 如果不存在，则创建 (a+b, 1) 这个键值对
                umap[a + b]++;
            }
        }

        // 3. 初始化结果计数器
        int count = 0;

        // 4. 遍历 C 和 D，寻找配对
        for (int c : C) {
            for (int d : D) {
                // 计算目标值
                int target = 0 - (c + d);
                
                // 在哈希表中查找是否存在这个目标值
                if (umap.find(target) != umap.end()) {
                    // 如果找到了，说明存在一个或多个 (a,b) 对，其和为 target
                    // umap[target] 存储了这样的 (a,b) 对有多少种
                    count += umap[target];
                }
            }
        }

        // 5. 返回总数
        return count;
    }
};
```

**代码亮点分析**:

*   **`umap[a + b]++`**: 这是 C++ `unordered_map` 中 `operator[]` 的一个非常方便的特性。如果键 `a+b` 不存在，它会自动创建一个新条目，并用默认值 `0` 初始化 `value`，然后再执行 `++` 操作，使其变为 `1`。如果键已存在，它就直接对 `value` 执行 `++`。这一行代码优雅地完成了统计频率的功能。
*   **分组降维**: 将 O(n⁴) 的问题分解成两个独立的 O(n²) 的问题，中间通过一个 O(1) 的哈希查找来连接，使得总时间复杂度降低到 **O(n²)**。
*   **空间换时间**: 算法使用了哈希表作为额外空间（最坏情况下空间复杂度为 O(n²)），来换取时间上的巨大优化。

这个解法是处理此类“多数组求和”问题的标准模板，务必掌握。